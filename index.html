<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton Tournament Manager</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; margin: 0; padding: 20px; background-color: #f0f2f5; color: #1c1e21; font-size: 14px; }
        header { background-color: #4A90E2; color: white; padding: 15px 20px; text-align: center; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        header h1 { margin: 0; font-size: 1.8em; }
        nav#event-tabs { margin-top: 10px; }
        nav#event-tabs button { padding: 10px 15px; margin: 0 5px; cursor: pointer; background-color: #357ABD; color: white; border: none; border-radius: 5px; font-size: 0.9em; transition: background-color 0.2s; }
        nav#event-tabs button:hover { background-color: #2A5C8D; }
        nav#event-tabs button.active { background-color: #1E4263; font-weight: bold; }
        
        #tournament-controls { text-align: center; margin-bottom: 20px; padding: 10px; background-color: #fff; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        #tournament-controls button { padding: 10px 18px; margin: 5px; cursor: pointer; color: white; border: none; border-radius: 5px; font-size: 0.95em; transition: background-color 0.2s, box-shadow 0.2s; }
        #tournament-controls button#save-all-teams { background-color: #4CAF50; } /* Green */
        #tournament-controls button#save-all-teams:hover { background-color: #45a049; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#reset-tournament { background-color: #f44336; } /* Red */
        #tournament-controls button#reset-tournament:hover { background-color: #e53935; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }

        .event-container { display: none; margin-top: 20px; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .event-container.active { display: block; }
        .event-container h2 { color: #4A90E2; margin-top:0; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;}

        .team-setup-area { margin-bottom: 25px; padding: 15px; background-color: #f9f9f9; border-radius: 6px; }
        .team-setup-area h3 { margin-top: 0; color: #333; }
        .team-input-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 10px; }
        .team-input-group { display: flex; align-items: center; background-color: #fff; padding: 8px; border: 1px solid #ddd; border-radius:4px;}
        .team-input-group label { display: inline-block; width: 100px; font-size: 0.9em; color: #555; margin-right: 5px; }
        .team-input-group input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex-grow:1; font-size: 0.9em;}
        
        .draw-section h3 { border-bottom: 2px solid #4A90E2; padding-bottom: 8px; margin-top: 25px; margin-bottom: 15px; color: #1E4263;}
        .draw { display: flex; flex-direction: row; overflow-x: auto; padding: 15px 5px; background-color: #fdfdfd; border: 1px solid #e0e0e0; border-radius: 6px; min-height: 350px;}
        .round { display: flex; flex-direction: column; justify-content: space-around; margin-right: 15px; padding: 0 10px; min-width: 280px; border-right: 1px dashed #d0d0d0; }
        .round:last-child { border-right: none; }
        .match { background-color: #ffffff; border: 1px solid #cccccc; border-radius: 6px; padding: 12px; margin: 12px 0; position: relative; box-shadow: 0 1px 3px rgba(0,0,0,0.08); transition: box-shadow 0.2s;}
        .match:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.12); }
        .match .team { display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #eee; }
        .match .team:last-child { border-bottom: none; }
        .match .team-name { flex-grow: 1; font-size: 0.95em; color: #333; }
        .match .scores-container { display: flex; }
        .match .score-input { width: 38px; padding: 5px; text-align: center; margin-left: 4px; border: 1px solid #bbb; border-radius: 3px; font-size: 0.9em;}
        .match .match-meta { font-size: 0.75em; color: #666; margin-bottom: 6px; text-align: right; }
        .match button.save-score { padding: 8px 12px; font-size: 0.9em; background-color: #5cb85c; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; display: block; width: 100%; transition: background-color 0.2s;}
        .match button.save-score:hover { background-color: #4cae4c; }
        .match .winner .team-name { font-weight: bold; color: #007bff; } 
        .match .loser .team-name { text-decoration: line-through; color: #777; }
        .bye { font-style: italic; color: #555; text-align: center; padding: 15px; background-color: #f8f9fa; border-radius: 4px; margin-top: 5px;}
        .match-complete-indicator { font-weight: bold; color: #28a745; margin-top: 5px; text-align: center; font-size:0.85em; }

        #loading-status { text-align: center; padding: 12px; background-color: #ffc107; color: #333; border-radius: 5px; margin-bottom:15px; font-weight:500;}
    </style>
</head>
<body>
    <header>
        <h1>Badminton Tournament Manager</h1>
        <nav id="event-tabs"></nav>
    </header>

    <div id="tournament-controls">
        <button id="save-all-teams">Save All Team Names</button>
        <button id="reset-tournament">Reset Tournament Data</button>
        <p id="loading-status" style="display:none;">Loading data...</p>
    </div>

    <div id="tournament-content">
        </div>

    <script>
        const EVENT_CODES = {
            BS: "Boy's Singles", GS: "Girl's Singles",
            BD: "Boy's Doubles", GD: "Girl's Doubles",
            XD: "Mixed Doubles"
        };
        const NUM_SCHOOLS = 16;
        const TEAMS_PER_SCHOOL = 2;
        const TOTAL_TEAMS_PER_EVENT = NUM_SCHOOLS * TEAMS_PER_SCHOOL; // 32

        let tournamentData = {};
        let currentEventId = 'BS'; // Default active event

        // --- Initialization and Data Persistence ---
        function initApp() {
            loadData();
            setupEventTabs(); 
            renderCurrentEvent(); 
            document.getElementById('reset-tournament').addEventListener('click', resetTournamentData);
            document.getElementById('save-all-teams').addEventListener('click', saveAllTeamNamesFromUI);
        }

        function saveData() {
            try {
                localStorage.setItem('badmintonTournamentData_v3.1', JSON.stringify(tournamentData)); 
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
                alert("Could not save data. LocalStorage might be full or disabled.");
            }
        }

        function loadData() {
            const statusEl = document.getElementById('loading-status');
            if(statusEl) statusEl.style.display = 'block';
            try {
                const storedData = localStorage.getItem('badmintonTournamentData_v3.1');
                if (storedData) {
                    tournamentData = JSON.parse(storedData);
                    Object.keys(EVENT_CODES).forEach(eventId => { 
                        if (!tournamentData[eventId]) {
                            tournamentData[eventId] = createEventObject(eventId);
                        } else { 
                            if (!tournamentData[eventId].teams || tournamentData[eventId].teams.length !== TOTAL_TEAMS_PER_EVENT) {
                                tournamentData[eventId].teams = createInitialTeams(eventId);
                            }
                            // Check for the new final matches, regenerate if structure seems old
                            const mdRounds = tournamentData[eventId].mainDraw && tournamentData[eventId].mainDraw.rounds;
                            const cdRounds = tournamentData[eventId].consolationDraw && tournamentData[eventId].consolationDraw.rounds;

                            if (!mdRounds || mdRounds.length < 6) { // 5 rounds + 1 overall final
                                tournamentData[eventId].mainDraw = generateMainDrawStructure(eventId);
                            }
                            if (!cdRounds || cdRounds.length < 8) { // 7 rounds + 1 third place
                                tournamentData[eventId].consolationDraw = generateConsolationDrawStructure(eventId);
                            }
                        }
                    });
                } else {
                    initializeNewTournament();
                }
            } catch (e) {
                console.error("Error loading data from localStorage:", e);
                initializeNewTournament(); 
            }
            if(statusEl) statusEl.style.display = 'none';
        }
        
        function initializeNewTournament() {
            tournamentData = {};
            Object.keys(EVENT_CODES).forEach(eventId => {
                tournamentData[eventId] = createEventObject(eventId);
            });
            saveData();
        }

        function createEventObject(eventId) {
            return {
                id: eventId,
                name: EVENT_CODES[eventId],
                teams: createInitialTeams(eventId),
                mainDraw: generateMainDrawStructure(eventId),
                consolationDraw: generateConsolationDrawStructure(eventId),
                setupComplete: false 
            };
        }

        function createInitialTeams(eventId) {
            const teams = [];
            for (let i = 0; i < NUM_SCHOOLS; i++) {
                for (let j = 0; j < TEAMS_PER_SCHOOL; j++) {
                    const teamId = `${eventId}_s${i+1}_t${j+1}`;
                    teams.push({
                        id: teamId,
                        name: `School ${i+1} - Team ${j+1}`,
                        originalPlayerSlot: teams.length, 
                        mainDrawLosses: 0,
                        consolationLosses: 0
                    });
                }
            }
            return teams;
        }

        function resetTournamentData() {
            if (confirm("Are you sure you want to reset all tournament data? This cannot be undone.")) {
                localStorage.removeItem('badmintonTournamentData_v3.1');
                initializeNewTournament();
                renderCurrentEvent(); 
                alert("Tournament data has been reset.");
            }
        }

        // --- Draw Generation Logic ---
        function createMatchObject(id, round, matchInRound, team1Source = null, team2Source = null, isSF = false, isFinal = false, customLabel = "") {
            return {
                id, round, matchInRound, customLabel,
                team1Id: null, team2Id: null,
                team1Source, team2Source, 
                score1: [], score2: [],
                winnerId: null, loserId: null,
                isBye: false, isComplete: false,
                isSF, isFinal, 
                isOverallChampionship: false, // New flag for the ultimate final
                isThirdPlacePlayoff: false, // New flag
                loserFeedsToConsolationMatchId: null, 
                loserFeedsToSlotNumber: null, 
            };
        }

        function generateMainDrawStructure(eventId) {
            const rounds = [];
            const numTeams = TOTAL_TEAMS_PER_EVENT; 
            let teamsInRound = numTeams;
            let roundNum = 1;

            // R1: 16 matches
            let roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1, 
                    { type: 'seed', slot: i * 2 }, { type: 'seed', slot: i * 2 + 1 }, false, false, `MD R1.${i+1}`);
                match.loserFeedsToConsolationMatchId = `CD1.${Math.floor(i/2) + 1}`;
                match.loserFeedsToSlotNumber = (i % 2 === 0) ? 1 : 2; 
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; 

            // R2: 8 matches
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` }, false, false, `MD R2.${i+1}`);
                match.loserFeedsToConsolationMatchId = `CD2.${i + 1}`;
                match.loserFeedsToSlotNumber = 2; 
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; 

            // R3 (QF): 4 matches
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` }, false, false, `MD QF.${i+1}`);
                match.loserFeedsToConsolationMatchId = `CD4.${i + 1}`; 
                match.loserFeedsToSlotNumber = 2; 
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; 

            // R4 (SF): 2 matches (Best of 3)
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` },
                    true, false, `MD SF.${i+1}`); 
                match.loserFeedsToConsolationMatchId = `CD6.${i + 1}`; 
                match.loserFeedsToSlotNumber = 2; 
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; 

            // R5 (Final): 1 match (Best of 3)
            roundMatches = [];
            const mdFinal = createMatchObject(`M${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `M${roundNum-1}.1` }, { type: 'winner', matchId: `M${roundNum-1}.2` },
                false, true, `MD Final`); 
            roundMatches.push(mdFinal);
            rounds.push(roundMatches);
            roundNum++;

            // R6 (Overall Championship): 1 match (Best of 3)
            roundMatches = [];
            const overallChampMatch = createMatchObject(`M${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: 'M5.1' }, // Winner of MD Final
                { type: 'winner', matchId: 'CD7.1' }, // Winner of CD Final
                false, true, `Overall Championship`); // isFinal for Bo3 logic
            overallChampMatch.isOverallChampionship = true;
            roundMatches.push(overallChampMatch);
            rounds.push(roundMatches);
            
            return { rounds };
        }

        function generateConsolationDrawStructure(eventId) {
            const rounds = [];
            let roundNum = 1; 

            // CD-R1: 8 matches (for 16 L_M1)
            let roundMatches = [];
            for (let i = 0; i < 8; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'loser', matchId: `M1.${i*2+1}` }, 
                    { type: 'loser', matchId: `M1.${i*2+2}` }, 
                    false, false, `CD R1.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R2: 8 matches (8 W_C1 vs 8 L_M2)
            roundMatches = [];
            for (let i = 0; i < 8; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M2.${i+1}` }, 
                    false, false, `CD R2.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R3 (Play-down for 8 W_C2): 4 matches
            roundMatches = [];
            for (let i = 0; i < 4; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+2}` },
                    false, false, `CD R3.${i+1} (Playdown)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R4 (4 W_C3 vs 4 L_M3/QF): 4 matches
            roundMatches = [];
            for (let i = 0; i < 4; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M3.${i+1}` }, 
                    false, false, `CD R4.${i+1} (vs QFL)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R5 (Play-down for 4 W_C4): 2 matches
            roundMatches = [];
            for (let i = 0; i < 2; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+2}` },
                    false, false, `CD R5.${i+1} (Playdown)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R6 (2 W_C5 vs 2 L_M4/SF): 2 matches (CD Semis)
            roundMatches = [];
            for (let i = 0; i < 2; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M4.${i+1}` }, 
                    false, false, `CD SF.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R7 (Consolation Final): 1 match
            roundMatches = [];
            const cdFinal = createMatchObject(`CD${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `CD${roundNum-1}.1` },
                { type: 'winner', matchId: `CD${roundNum-1}.2` },
                false, true, `CD Final`); // isFinal for label, single game by default for CD
            roundMatches.push(cdFinal);
            rounds.push(roundMatches); roundNum++;

            // CD-R8 (Third Place Playoff): 1 match (single game)
            roundMatches = [];
            const thirdPlaceMatch = createMatchObject(`CD${roundNum}.1`, roundNum, 1,
                { type: 'loser', matchId: 'M5.1' }, // Loser of MD Final
                { type: 'loser', matchId: 'CD7.1' }, // Loser of CD Final
                false, false, `3rd Place Playoff`); 
            thirdPlaceMatch.isThirdPlacePlayoff = true;
            roundMatches.push(thirdPlaceMatch);
            rounds.push(roundMatches);

            return { rounds };
        }


        // --- UI Rendering ---
        function setupEventTabs() {
            const tabsContainer = document.getElementById('event-tabs');
            tabsContainer.innerHTML = ''; 
            Object.keys(EVENT_CODES).forEach(eventId => {
                const button = document.createElement('button');
                button.dataset.event = eventId;
                button.textContent = EVENT_CODES[eventId];
                if (eventId === currentEventId) button.classList.add('active');
                button.addEventListener('click', () => switchEventTab(eventId));
                tabsContainer.appendChild(button);
            });

            const tournamentContentEl = document.getElementById('tournament-content');
            tournamentContentEl.innerHTML = ''; 
            Object.keys(EVENT_CODES).forEach(eventId => {
                const eventDiv = document.createElement('div');
                eventDiv.id = `event-${eventId}-container`;
                eventDiv.classList.add('event-container');
                if (eventId === currentEventId) eventDiv.classList.add('active');
                
                eventDiv.innerHTML = `
                    <h2>${EVENT_CODES[eventId]}</h2>
                    <div id="team-setup-area-${eventId}" class="team-setup-area">
                        <h3>Team Names Entry</h3>
                        <div id="team-names-input-${eventId}" class="team-input-grid"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Main Draw</h3>
                        <div id="main-draw-${eventId}" class="draw"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Consolation Draw</h3>
                        <div id="consolation-draw-${eventId}" class="draw"></div>
                    </div>
                `;
                tournamentContentEl.appendChild(eventDiv);
            });
        }

        function switchEventTab(eventId) {
            currentEventId = eventId;
            document.querySelectorAll('#event-tabs button').forEach(btn => btn.classList.remove('active'));
            const currentButton = document.querySelector(`#event-tabs button[data-event="${eventId}"]`);
            if (currentButton) currentButton.classList.add('active');
            
            document.querySelectorAll('.event-container').forEach(container => container.classList.remove('active'));
            const currentContainer = document.getElementById(`event-${eventId}-container`);
            if (currentContainer) currentContainer.classList.add('active');
            renderCurrentEvent();
        }

        function renderCurrentEvent() {
            const eventData = tournamentData[currentEventId];
            if (!eventData) return;
            
            renderTeamSetupUI(currentEventId);
            populateAllDrawsForEvent(currentEventId); 
            renderDraw(eventData.mainDraw, `main-draw-${currentEventId}`, currentEventId, 'MD');
            renderDraw(eventData.consolationDraw, `consolation-draw-${currentEventId}`, currentEventId, 'CD');
        }

        function renderTeamSetupUI(eventId) {
            const container = document.getElementById(`team-names-input-${eventId}`);
            if (!container) return;
            container.innerHTML = '';
            const teams = tournamentData[eventId].teams;
            teams.forEach((team, index) => {
                const group = document.createElement('div');
                group.classList.add('team-input-group');
                const label = document.createElement('label');
                label.setAttribute('for', `team-name-${eventId}-${index}`);
                label.textContent = `Entry ${index + 1}:`; 
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `team-name-${eventId}-${index}`;
                input.dataset.teamId = team.id;
                input.value = team.name;
                group.appendChild(label);
                group.appendChild(input);
                container.appendChild(group);
            });
        }
        
        function saveAllTeamNamesFromUI() {
            let changesMade = false;
            Object.keys(EVENT_CODES).forEach(eventId => {
                const event = tournamentData[eventId];
                if (!event || !event.teams) return;
                event.teams.forEach((team, index) => {
                    const inputElement = document.getElementById(`team-name-${eventId}-${index}`);
                    if (inputElement && inputElement.value !== team.name) {
                        team.name = inputElement.value;
                        changesMade = true;
                    }
                });
            });

            if (changesMade) {
                saveData();
                renderCurrentEvent(); 
                alert("All team names saved!");
            } else {
                alert("No changes to team names detected.");
            }
        }

        function renderDraw(drawData, containerId, eventId, drawTypePrefix) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ''; 

            if (!drawData || !drawData.rounds || drawData.rounds.length === 0) {
                container.innerHTML = '<p style="padding:10px; color:#777;">Draw not generated yet or no matches.</p>';
                return;
            }

            drawData.rounds.forEach((roundMatches, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.classList.add('round');
                roundDiv.dataset.roundIndex = roundIndex;

                roundMatches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.classList.add('match');
                    matchDiv.id = `match-${eventId}-${match.id}`; 
                    
                    const team1Name = getTeamNameById(currentEventId, match.team1Id) || (match.team1Id === 'BYE' ? 'BYE' : 'TBD');
                    const team2Name = getTeamNameById(currentEventId, match.team2Id) || (match.team2Id === 'BYE' ? 'BYE' : 'TBD');
                    
                    let scoreInputs1 = '', scoreInputs2 = '';
                    
                    const isBo3 = (drawTypePrefix === 'MD' && (match.isSF || match.isFinal || match.isOverallChampionship)) || 
                                  (drawTypePrefix === 'CD' && match.isFinal); // CD Final is Bo3, Third place is single
                    const numGamesToPlay = isBo3 ? 3 : 1;


                    for (let g = 0; g < numGamesToPlay; g++) {
                        scoreInputs1 += `<input type="number" class="score-input team1-game${g+1}" min="0" max="30" ${match.isComplete ? 'disabled' : ''} value="${match.score1[g] !== undefined && match.score1[g] !== null ? match.score1[g] : ''}" title="Game ${g+1} Score for ${team1Name}"> `;
                        scoreInputs2 += `<input type="number" class="score-input team2-game${g+1}" min="0" max="30" ${match.isComplete ? 'disabled' : ''} value="${match.score2[g] !== undefined && match.score2[g] !== null ? match.score2[g] : ''}" title="Game ${g+1} Score for ${team2Name}"> `;
                    }
                    
                    let matchLabel = match.customLabel || `${match.id}`;
                    if (isBo3 && !match.customLabel.includes("Best of 3")) matchLabel += " (Best of 3)";


                    matchDiv.innerHTML = `
                        <div class="match-meta">${matchLabel}</div>
                        <div class="team ${match.winnerId === match.team1Id && match.isComplete ? 'winner' : (match.loserId === match.team1Id && match.isComplete ? 'loser' : '')}">
                            <span class="team-name">${team1Name}</span>
                            <span class="scores-container">${scoreInputs1}</span>
                        </div>
                        <div class="team ${match.winnerId === match.team2Id && match.isComplete ? 'winner' : (match.loserId === match.team2Id && match.isComplete ? 'loser' : '')}">
                            <span class="team-name">${team2Name}</span>
                            <span class="scores-container">${scoreInputs2}</span>
                        </div>
                        ${!match.isComplete && match.team1Id && match.team2Id && match.team1Id !== 'BYE' && match.team2Id !== 'BYE' ? 
                            `<button class="save-score" onclick="handleScoreSave('${currentEventId}', '${drawTypePrefix}', '${match.id}')">Save Score</button>` : ''}
                        ${match.isBye ? `<div class="bye">${getTeamNameById(currentEventId, match.winnerId)} advances (BYE)</div>` : ''}
                        ${match.isComplete && !match.isBye ? `<div class="match-complete-indicator">Winner: ${getTeamNameById(currentEventId, match.winnerId)}</div>` : ''}
                    `;
                    roundDiv.appendChild(matchDiv);
                });
                container.appendChild(roundDiv);
            });
        }

        function getTeamNameById(eventId, teamId) {
            if (!teamId) return 'TBD'; 
            if (teamId === 'BYE') return 'BYE';
            const event = tournamentData[eventId];
            if (!event || !event.teams) return teamId; 
            const team = event.teams.find(t => t.id === teamId);
            return team ? team.name : teamId; 
        }
        
        function findMatchById(eventId, drawTypePrefix, matchId) {
            const event = tournamentData[eventId];
            if (!event) return null;
            const draw = drawTypePrefix === 'MD' ? event.mainDraw : event.consolationDraw;
            if (!draw || !draw.rounds) return null;
            for (const round of draw.rounds) {
                const foundMatch = round.find(m => m.id === matchId);
                if (foundMatch) return foundMatch;
            }
            return null;
        }

        // --- Scoring Rules ---
        function checkGameWinner(s1, s2) {
            if (s1 === null || s2 === null || s1 === undefined || s2 === undefined || isNaN(s1) || isNaN(s2)) return null; 

            const p1 = parseInt(s1);
            const p2 = parseInt(s2);

            if (p1 === 30 && p1 > p2) return 1; 
            if (p2 === 30 && p2 > p1) return 2; 
            if (p1 < 30 && p2 < 30) { 
                if (p1 >= 21 && p1 >= p2 + 2) return 1; 
                if (p2 >= 21 && p2 >= p1 + 2) return 2; 
            }
            return null; 
        }

        // --- Score Handling and Advancement ---
        function handleScoreSave(eventId, drawTypePrefix, matchId) {
            const match = findMatchById(eventId, drawTypePrefix, matchId);
            if (!match) { console.error("Match not found:", matchId); return; }

            const isBo3 = (drawTypePrefix === 'MD' && (match.isSF || match.isFinal || match.isOverallChampionship)) || 
                          (drawTypePrefix === 'CD' && match.isFinal && !match.isThirdPlacePlayoff) ; // CD Final is Bo3, 3rd place is not
            const numGamesToPlay = isBo3 ? 3 : 1;
            
            const collectedScores1 = [], collectedScores2 = [];
            const matchDiv = document.getElementById(`match-${eventId}-${match.id}`);
            if (!matchDiv) { console.error("Match div not found for scores:", `match-${eventId}-${match.id}`); return; }

            for (let g = 0; g < numGamesToPlay; g++) {
                const s1El = matchDiv.querySelector(`.team1-game${g+1}`);
                const s2El = matchDiv.querySelector(`.team2-game${g+1}`);
                if (!s1El || !s2El) { collectedScores1.push(null); collectedScores2.push(null); continue;}

                const s1Val = s1El.value;
                const s2Val = s2El.value;
                
                collectedScores1.push(s1Val === '' ? null : parseInt(s1Val));
                collectedScores2.push(s2Val === '' ? null : parseInt(s2Val));
            }
            match.score1 = collectedScores1; 
            match.score2 = collectedScores2;

            let team1MatchGamesWon = 0;
            let team2MatchGamesWon = 0;
            let allRequiredGamesValidlyScored = true;

            for (let g = 0; g < numGamesToPlay; g++) {
                // If we already have a match winner in Bo3, don't need to validate further game scores
                if (isBo3 && (team1MatchGamesWon >= 2 || team2MatchGamesWon >= 2)) break;

                const gameWinner = checkGameWinner(match.score1[g], match.score2[g]);
                if (gameWinner === 1) {
                    team1MatchGamesWon++;
                } else if (gameWinner === 2) {
                    team2MatchGamesWon++;
                } else {
                    // If score is entered for this game but it's not a valid win, then scoring is incomplete/invalid for this game
                    if (match.score1[g] !== null || match.score2[g] !== null) { 
                       allRequiredGamesValidlyScored = false;
                    }
                }
            }
            
            // Determine match winner
            if (!isBo3) { // Single game
                if (team1MatchGamesWon === 1) match.winnerId = match.team1Id;
                else if (team2MatchGamesWon === 1) match.winnerId = match.team2Id;
                else { allRequiredGamesValidlyScored = false; } // Winner not determined
            } else { // Best of 3
                if (team1MatchGamesWon >= 2) match.winnerId = match.team1Id;
                else if (team2MatchGamesWon >= 2) match.winnerId = match.team2Id;
                else { allRequiredGamesValidlyScored = false; } // Winner not determined
            }
            
            if (!allRequiredGamesValidlyScored) {
                 alert(`Match scores for ${match.id} are incomplete or invalid. For single games, one player must win. For Best of 3, two games must be won. Each game requires a clear winner (21 points, win by 2, cap 30). Please check scores.`);
                 match.winnerId = null; // Ensure winner is not set if scores are invalid
                 return;
            }
            
            match.loserId = (match.winnerId === match.team1Id) ? match.team2Id : match.team1Id;
            match.isComplete = true;

            // Only update mainDrawLosses/consolationLosses for bracket progression, not for final placement matches
            if (!match.isOverallChampionship && !match.isThirdPlacePlayoff) {
                const loserTeamObj = tournamentData[eventId].teams.find(t => t.id === match.loserId);
                if (loserTeamObj) { 
                    if (drawTypePrefix === 'MD') {
                        loserTeamObj.mainDrawLosses++;
                    } else { 
                        loserTeamObj.consolationLosses++;
                    }
                }
            }
            
            saveData();
            renderCurrentEvent(); 
        }
        
        function populateAllDrawsForEvent(eventId) {
            const event = tournamentData[eventId];
            if (!event) return;
            
            let maxIterations = 7; // Increased slightly due to more cross-draw dependencies
            let iteration = 0;
            let changedInIteration;

            do {
                changedInIteration = false;
                const originalTeamAssignments = JSON.stringify({
                    md: event.mainDraw.rounds.map(r => r.map(m => ({id: m.id, t1: m.team1Id, t2: m.team2Id, c: m.isComplete, w: m.winnerId, l:m.loserId}))),
                    cd: event.consolationDraw.rounds.map(r => r.map(m => ({id: m.id, t1: m.team1Id, t2: m.team2Id, c: m.isComplete, w: m.winnerId, l:m.loserId})))
                });

                populateSpecificDraw(eventId, event.mainDraw, 'MD');
                populateSpecificDraw(eventId, event.consolationDraw, 'CD');

                const newTeamAssignments = JSON.stringify({
                    md: event.mainDraw.rounds.map(r => r.map(m => ({id: m.id, t1: m.team1Id, t2: m.team2Id, c: m.isComplete, w: m.winnerId, l:m.loserId}))),
                    cd: event.consolationDraw.rounds.map(r => r.map(m => ({id: m.id, t1: m.team1Id, t2: m.team2Id, c: m.isComplete, w: m.winnerId, l:m.loserId})))
                });
                
                if (originalTeamAssignments !== newTeamAssignments) {
                    changedInIteration = true;
                }
                iteration++;
            } while (changedInIteration && iteration < maxIterations);
             if (iteration === maxIterations && changedInIteration) {
                console.warn("Max population iterations reached, but changes were still happening. Draw might not be fully stable.");
            }
        }


        function populateSpecificDraw(eventId, drawData, drawTypePrefix) {
            const event = tournamentData[eventId];
            if (!drawData || !drawData.rounds) return;

            drawData.rounds.forEach(round => {
                round.forEach(match => {
                    if (match.isComplete && !match.isBye) return; 
                                                           
                    // Populate team1Id
                    if (!match.team1Id || match.team1Id === 'TBD') { 
                        const p1Id = getPlayerIdFromSource(eventId, match.team1Source); // Removed extra params
                        if (p1Id) match.team1Id = p1Id;
                    }
                    // Populate team2Id
                    if (!match.team2Id || match.team2Id === 'TBD') {
                        const p2Id = getPlayerIdFromSource(eventId, match.team2Source); // Removed extra params
                        if (p2Id) match.team2Id = p2Id;
                    }

                    // Auto-complete BYEs
                    if (!match.isComplete) { 
                        let newByeWinner = null;
                        if (match.team1Id === 'BYE' && match.team2Id && match.team2Id !== 'BYE' && match.team2Id !== 'TBD') {
                            newByeWinner = match.team2Id;
                        } else if (match.team2Id === 'BYE' && match.team1Id && match.team1Id !== 'BYE' && match.team1Id !== 'TBD') {
                            newByeWinner = match.team1Id;
                        } else if (match.team1Id === 'BYE' && match.team2Id === 'BYE') {
                            newByeWinner = 'BYE'; 
                        }
                        
                        if (newByeWinner) {
                             match.winnerId = newByeWinner;
                             match.loserId = (newByeWinner === match.team1Id) ? match.team2Id : match.team1Id; 
                             match.isComplete = true;
                             match.isBye = true;
                             match.score1 = []; match.score2 = []; 
                        }
                    }

                    if (drawTypePrefix === 'MD' && match.isComplete && match.loserFeedsToConsolationMatchId) {
                        const loserIdToFeed = match.loserId; 
                        const cdMatchToFeed = findMatchById(eventId, 'CD', match.loserFeedsToConsolationMatchId);

                        if (cdMatchToFeed && !cdMatchToFeed.isComplete) { 
                            let slotFilled = false;
                            if (match.loserFeedsToSlotNumber === 1 && (!cdMatchToFeed.team1Id || cdMatchToFeed.team1Id === 'TBD')) {
                                cdMatchToFeed.team1Id = loserIdToFeed;
                                slotFilled = true;
                            } else if (match.loserFeedsToSlotNumber === 2 && (!cdMatchToFeed.team2Id || cdMatchToFeed.team2Id === 'TBD')) {
                                cdMatchToFeed.team2Id = loserIdToFeed;
                                slotFilled = true;
                            }

                            if (slotFilled && !cdMatchToFeed.isComplete) {
                                let cdByeWinner = null;
                                if (cdMatchToFeed.team1Id === 'BYE' && cdMatchToFeed.team2Id && cdMatchToFeed.team2Id !== 'BYE' && cdMatchToFeed.team2Id !== 'TBD') {
                                    cdByeWinner = cdMatchToFeed.team2Id;
                                } else if (cdMatchToFeed.team2Id === 'BYE' && cdMatchToFeed.team1Id && cdMatchToFeed.team1Id !== 'BYE' && cdMatchToFeed.team1Id !== 'TBD') {
                                    cdByeWinner = cdMatchToFeed.team1Id;
                                }
                                if (cdByeWinner) {
                                    cdMatchToFeed.winnerId = cdByeWinner;
                                    cdMatchToFeed.loserId = (cdByeWinner === cdMatchToFeed.team1Id) ? cdMatchToFeed.team2Id : cdMatchToFeed.team1Id;
                                    cdMatchToFeed.isComplete = true; cdMatchToFeed.isBye = true;
                                    cdMatchToFeed.score1 = []; cdMatchToFeed.score2 = [];
                                }
                            }
                        }
                    }
                });
            });
        }

        function getPlayerIdFromSource(eventId, source) { // Removed unused params
            if (!source) return null;
            const event = tournamentData[eventId];

            if (source.type === 'seed') {
                return event.teams[source.slot] ? event.teams[source.slot].id : 'BYE';
            } else if (source.type === 'winner') {
                const sourceDrawType = source.matchId.startsWith('M') ? 'MD' : 'CD';
                const sourceMatch = findMatchById(eventId, sourceDrawType, source.matchId);
                if (sourceMatch && sourceMatch.isComplete) {
                    return sourceMatch.winnerId; 
                }
                return null; 
            } else if (source.type === 'loser') {
                const sourceDrawType = source.matchId.startsWith('M') ? 'MD' : 'CD';
                const sourceMatch = findMatchById(eventId, sourceDrawType, source.matchId);
                
                if (sourceMatch && sourceMatch.isComplete) {
                    // If the source match resulted in a BYE winner, its "loser" is also effectively BYE for feeding purposes
                    if (sourceMatch.isBye && sourceMatch.winnerId !== 'BYE') { 
                        return (sourceMatch.winnerId === sourceMatch.team1Id && sourceMatch.team2Id === 'BYE') ? 'BYE' : 
                               (sourceMatch.winnerId === sourceMatch.team2Id && sourceMatch.team1Id === 'BYE') ? 'BYE' :
                               sourceMatch.loserId; // Should be 'BYE' if one player got a bye
                    }
                    if (sourceMatch.loserId === null && sourceMatch.winnerId === 'BYE') return 'BYE'; 
                    return sourceMatch.loserId || 'BYE'; // Default to BYE if loserId is null but match is complete
                }
                return null; 
            }
            return null;
        }

        // --- Entry Point ---
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>
