<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton Tournament Manager</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; margin: 0; padding: 20px; background-color: #f0f2f5; color: #1c1e21; font-size: 14px; }
        header { background-color: #4A90E2; color: white; padding: 15px 20px; text-align: center; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        header h1 { margin: 0; font-size: 1.8em; }
        nav#event-tabs { margin-top: 10px; }
        nav#event-tabs button { padding: 10px 15px; margin: 0 5px; cursor: pointer; background-color: #357ABD; color: white; border: none; border-radius: 5px; font-size: 0.9em; transition: background-color 0.2s; }
        nav#event-tabs button:hover { background-color: #2A5C8D; }
        nav#event-tabs button.active { background-color: #1E4263; font-weight: bold; }
        
        #tournament-controls { text-align: center; margin-bottom: 20px; padding: 10px; background-color: #fff; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        #tournament-controls button { padding: 10px 18px; margin: 5px; cursor: pointer; color: white; border: none; border-radius: 5px; font-size: 0.95em; transition: background-color 0.2s, box-shadow 0.2s; }
        #tournament-controls button#save-all-teams { background-color: #4CAF50; } /* Green */
        #tournament-controls button#save-all-teams:hover { background-color: #45a049; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#shuffle-current-event-teams { background-color: #FF9800; } /* Orange */
        #tournament-controls button#shuffle-current-event-teams:hover { background-color: #FB8C00; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#reset-tournament { background-color: #f44336; } /* Red */
        #tournament-controls button#reset-tournament:hover { background-color: #e53935; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#export-data { background-color: #007bff; } /* Blue */
        #tournament-controls button#export-data:hover { background-color: #0069d9; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#import-data { background-color: #17a2b8; } /* Teal */
        #tournament-controls button#import-data:hover { background-color: #138496; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }


        .event-container { display: none; margin-top: 20px; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .event-container.active { display: block; }
        .event-container h2 { color: #4A90E2; margin-top:0; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;}

        .team-setup-area { margin-bottom: 25px; padding: 15px; background-color: #f9f9f9; border-radius: 6px; }
        .team-setup-area h3 { margin-top: 0; color: #333; }
        .team-input-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 10px; }
        .team-input-group { display: flex; align-items: center; background-color: #fff; padding: 8px; border: 1px solid #ddd; border-radius:4px;}
        .team-input-group label { display: inline-block; width: 100px; font-size: 0.9em; color: #555; margin-right: 5px; }
        .team-input-group input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex-grow:1; font-size: 0.9em;}
        
        .draw-section h3 { border-bottom: 2px solid #4A90E2; padding-bottom: 8px; margin-top: 25px; margin-bottom: 15px; color: #1E4263;}
        .draw { display: flex; flex-direction: row; overflow-x: auto; padding: 15px 5px; background-color: #fdfdfd; border: 1px solid #e0e0e0; border-radius: 6px; min-height: 350px;}
        .round { display: flex; flex-direction: column; justify-content: space-around; margin-right: 15px; padding: 0 10px; min-width: 280px; border-right: 1px dashed #d0d0d0; }
        .round:last-child { border-right: none; }
        .match { background-color: #ffffff; border: 1px solid #cccccc; border-radius: 6px; padding: 12px; margin: 12px 0; position: relative; box-shadow: 0 1px 3px rgba(0,0,0,0.08); transition: box-shadow 0.2s;}
        .match:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.12); }
        .match .team { display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #eee; }
        .match .team:last-child { border-bottom: none; }
        .match .team-name { flex-grow: 1; font-size: 0.95em; color: #333; }
        .match .scores-container { display: flex; }
        .match .score-input { width: 38px; padding: 5px; text-align: center; margin-left: 4px; border: 1px solid #bbb; border-radius: 3px; font-size: 0.9em;}
        .match .match-meta { font-size: 0.75em; color: #666; margin-bottom: 6px; text-align: right; }
        .match button.save-score { padding: 8px 12px; font-size: 0.9em; background-color: #5cb85c; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; display: block; width: 100%; transition: background-color 0.2s;}
        .match button.save-score:hover { background-color: #4cae4c; }
        .match .winner .team-name { font-weight: bold; color: #007bff; } 
        .match .loser .team-name { text-decoration: line-through; color: #777; }
        .bye { font-style: italic; color: #555; text-align: center; padding: 15px; background-color: #f8f9fa; border-radius: 4px; margin-top: 5px;}
        .match-complete-indicator { font-weight: bold; color: #28a745; margin-top: 5px; text-align: center; font-size:0.85em; }

        #loading-status { text-align: center; padding: 12px; background-color: #ffc107; color: #333; border-radius: 5px; margin-bottom:15px; font-weight:500;}
    </style>
</head>
<body>
    <header>
        <h1>Badminton Tournament Manager</h1>
        <nav id="event-tabs"></nav>
    </header>

    <div id="tournament-controls">
        <button id="save-all-teams">Save All Team Names</button>
        <button id="shuffle-current-event-teams">Shuffle Current Event Entries</button>
        <button id="reset-tournament">Reset Tournament Data</button>
        <button id="export-data">Export Tournament Data (JSON)</button>
        <button id="import-data">Import Tournament Data (JSON)</button>
        <input type="file" id="import-file-input" accept=".json" style="display: none;">
        <p id="loading-status" style="display:none;">Loading data...</p>
    </div>

    <div id="tournament-content">
        </div>

    <script>
        const EVENT_CODES = {
            BS: "Boy's Singles", GS: "Girl's Singles",
            BD: "Boy's Doubles", GD: "Girl's Doubles",
            XD: "Mixed Doubles"
        };
        const NUM_SCHOOLS = 16;
        const TEAMS_PER_SCHOOL = 2;
        const TOTAL_TEAMS_PER_EVENT = NUM_SCHOOLS * TEAMS_PER_SCHOOL; // 32

        let tournamentData = {};
        let currentEventId = 'BS'; // Default active event

        // --- Initialization and Data Persistence ---
        function initApp() {
            loadData();
            setupEventTabs(); 
            renderCurrentEvent(); 
            document.getElementById('reset-tournament').addEventListener('click', resetTournamentData);
            document.getElementById('save-all-teams').addEventListener('click', saveAllTeamNamesFromUI);
            document.getElementById('shuffle-current-event-teams').addEventListener('click', shuffleCurrentEventTeams);
            // New listeners for import/export
            document.getElementById('export-data').addEventListener('click', exportTournamentData);
            document.getElementById('import-data').addEventListener('click', () => {
                document.getElementById('import-file-input').click();
            });
            document.getElementById('import-file-input').addEventListener('change', handleTournamentDataUpload);

        }

        function saveData() {
            try {
                localStorage.setItem('badmintonTournamentData_v3.1', JSON.stringify(tournamentData)); 
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
                alert("Could not save data. LocalStorage might be full or disabled.");
            }
        }

        function loadData() {
            const statusEl = document.getElementById('loading-status');
            if(statusEl) statusEl.style.display = 'block';
            try {
                const storedData = localStorage.getItem('badmintonTournamentData_v3.1');
                if (storedData) {
                    tournamentData = JSON.parse(storedData);
                    // Validate and potentially repair loaded data
                    Object.keys(EVENT_CODES).forEach(eventId => { 
                        if (!tournamentData[eventId]) {
                            tournamentData[eventId] = createEventObject(eventId);
                        } else { 
                            // Ensure teams array is correct
                            if (!tournamentData[eventId].teams || !Array.isArray(tournamentData[eventId].teams) || tournamentData[eventId].teams.length !== TOTAL_TEAMS_PER_EVENT) {
                                tournamentData[eventId].teams = createInitialTeams(eventId);
                            }
                            // Ensure main draw structure
                            const mdRounds = tournamentData[eventId].mainDraw && tournamentData[eventId].mainDraw.rounds;
                            if (!mdRounds || !Array.isArray(mdRounds) || mdRounds.length < 6) { // 5 rounds + 1 overall final
                                tournamentData[eventId].mainDraw = generateMainDrawStructure(eventId);
                            }
                            // Ensure consolation draw structure
                            const cdRounds = tournamentData[eventId].consolationDraw && tournamentData[eventId].consolationDraw.rounds;
                            if (!cdRounds || !Array.isArray(cdRounds) || cdRounds.length < 8) { // 7 rounds + 1 third place
                                tournamentData[eventId].consolationDraw = generateConsolationDrawStructure(eventId);
                            }
                        }
                    });
                } else {
                    initializeNewTournament();
                }
            } catch (e) {
                console.error("Error loading data from localStorage:", e);
                initializeNewTournament(); 
            }
            if(statusEl) statusEl.style.display = 'none';
        }
        
        function initializeNewTournament() {
            tournamentData = {};
            Object.keys(EVENT_CODES).forEach(eventId => {
                tournamentData[eventId] = createEventObject(eventId);
            });
            saveData();
        }

        function createEventObject(eventId) {
            return {
                id: eventId,
                name: EVENT_CODES[eventId],
                teams: createInitialTeams(eventId),
                mainDraw: generateMainDrawStructure(eventId),
                consolationDraw: generateConsolationDrawStructure(eventId),
                setupComplete: false 
            };
        }

        function createInitialTeams(eventId) {
            const teams = [];
            for (let i = 0; i < NUM_SCHOOLS; i++) {
                for (let j = 0; j < TEAMS_PER_SCHOOL; j++) {
                    const teamId = `${eventId}_s${i+1}_t${j+1}`;
                    teams.push({
                        id: teamId,
                        name: `School ${i+1} - Team ${j+1}`,
                        originalPlayerSlot: teams.length, 
                        mainDrawLosses: 0,
                        consolationLosses: 0
                    });
                }
            }
            return teams;
        }

        function resetTournamentData() {
            if (confirm("Are you sure you want to reset all tournament data? This cannot be undone.")) {
                localStorage.removeItem('badmintonTournamentData_v3.1');
                initializeNewTournament();
                renderCurrentEvent(); 
                alert("Tournament data has been reset.");
            }
        }

        // --- Import/Export Feature ---
        function exportTournamentData() {
            try {
                const jsonData = JSON.stringify(tournamentData, null, 2); // Pretty print JSON
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, "-");
                a.download = `badminton_tournament_data_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert("Tournament data exported successfully!");
            } catch (e) {
                console.error("Error exporting data:", e);
                alert("Could not export data. See console for details.");
            }
        }

        function handleTournamentDataUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            if (!confirm("Importing data will overwrite any existing tournament data. Are you sure you want to proceed?")) {
                event.target.value = null; // Reset file input
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedRawData = JSON.parse(e.target.result);
                    const validatedData = {};
                    let importSuccessful = true;

                    Object.keys(EVENT_CODES).forEach(appEventId => {
                        if (importedRawData[appEventId]) {
                            // Deep copy the event data
                            const eventData = JSON.parse(JSON.stringify(importedRawData[appEventId]));

                            // Validate and repair teams
                            if (!eventData.teams || !Array.isArray(eventData.teams) || eventData.teams.length !== TOTAL_TEAMS_PER_EVENT) {
                                console.warn(`Teams for event ${appEventId} are missing or malformed in imported data. Re-initializing teams for this event.`);
                                eventData.teams = createInitialTeams(appEventId);
                            } else {
                                // Further check team objects structure if necessary
                                eventData.teams.forEach((team, index) => {
                                    if (typeof team.id !== 'string' || typeof team.name !== 'string') {
                                        console.warn(`Team ${index} in event ${appEventId} has malformed structure. Re-initializing all teams for safety.`);
                                        eventData.teams = createInitialTeams(appEventId);
                                        return; // Exit forEach for teams
                                    }
                                    team.mainDrawLosses = team.mainDrawLosses || 0;
                                    team.consolationLosses = team.consolationLosses || 0;
                                });
                            }

                            // Validate and repair main draw
                            const mdRounds = eventData.mainDraw && eventData.mainDraw.rounds;
                            if (!mdRounds || !Array.isArray(mdRounds) || mdRounds.length < 6) {
                                console.warn(`Main draw for event ${appEventId} is missing or malformed. Re-generating draw structure.`);
                                eventData.mainDraw = generateMainDrawStructure(appEventId);
                            }

                            // Validate and repair consolation draw
                            const cdRounds = eventData.consolationDraw && eventData.consolationDraw.rounds;
                            if (!cdRounds || !Array.isArray(cdRounds) || cdRounds.length < 8) {
                                console.warn(`Consolation draw for event ${appEventId} is missing or malformed. Re-generating draw structure.`);
                                eventData.consolationDraw = generateConsolationDrawStructure(appEventId);
                            }
                            
                            // Ensure all matches have the necessary fields after potential regeneration or if directly from file
                            [eventData.mainDraw, eventData.consolationDraw].forEach(draw => {
                                if (draw && draw.rounds) {
                                    draw.rounds.forEach(round => {
                                        round.forEach(match => {
                                            // Ensure essential score arrays exist even if empty
                                            if (!Array.isArray(match.score1)) match.score1 = [];
                                            if (!Array.isArray(match.score2)) match.score2 = [];
                                            // Ensure boolean flags have default values
                                            match.isComplete = !!match.isComplete;
                                            match.isBye = !!match.isBye;
                                        });
                                    });
                                }
                            });

                            validatedData[appEventId] = eventData;
                        } else {
                            console.warn(`Event ${appEventId} not found in imported data. Initializing as new.`);
                            validatedData[appEventId] = createEventObject(appEventId);
                        }
                    });
                    
                    // Check if any valid event data was actually processed
                    if (Object.keys(validatedData).length === 0 && Object.keys(EVENT_CODES).length > 0) {
                        alert("Import failed: The imported file does not seem to contain recognizable tournament data for the configured events.");
                        importSuccessful = false;
                    }

                    if (importSuccessful) {
                        tournamentData = validatedData;
                        saveData();
                        alert("Tournament data imported successfully! The page will now refresh with the new data.");
                        
                        // Full UI refresh
                        const statusEl = document.getElementById('loading-status');
                        if(statusEl) statusEl.style.display = 'block';
                        
                        // Ensure event tabs and containers are rebuilt
                        setupEventTabs(); 
                        
                        // Attempt to restore the current event tab, or default to the first one
                        let firstEventId = Object.keys(EVENT_CODES)[0];
                        if (!EVENT_CODES[currentEventId] || !tournamentData[currentEventId]) { // if currentEventId is no longer valid
                            currentEventId = firstEventId;
                        }
                        switchEventTab(currentEventId); // This will call renderCurrentEvent

                        if(statusEl) statusEl.style.display = 'none';
                    }

                } catch (e) {
                    console.error("Error processing imported JSON file:", e);
                    alert("Failed to import data. The file might be corrupted or not in the correct JSON format. Please check the console for details.");
                } finally {
                    event.target.value = null; // Reset file input to allow re-upload of the same file
                }
            };
            reader.onerror = function() {
                alert("Error reading the file.");
                event.target.value = null;
            };
            reader.readAsText(file);
        }


        // --- Shuffle Feature ---
        function shuffleCurrentEventTeams() {
            const eventData = tournamentData[currentEventId];
            if (!eventData) {
                alert("No event selected or event data not found.");
                return;
            }

            let actionTakenInEvent = false;
            const drawsToCheck = [eventData.mainDraw, eventData.consolationDraw];

            for (const draw of drawsToCheck) {
                if (draw && draw.rounds) {
                    for (const round of draw.rounds) {
                        for (const match of round) {
                            if (match.isComplete && !match.isBye) {
                                actionTakenInEvent = true;
                                break;
                            }
                            const hasEnteredScores = (m) => {
                                const s1NotEmpty = m.score1 && m.score1.some(s => s !== null && s !== undefined && String(s).trim() !== '');
                                const s2NotEmpty = m.score2 && m.score2.some(s => s !== null && s !== undefined && String(s).trim() !== '');
                                return s1NotEmpty || s2NotEmpty;
                            };
                            if (!match.isComplete && hasEnteredScores(match) && match.team1Id && match.team2Id && match.team1Id !== 'BYE' && match.team2Id !== 'BYE') {
                                actionTakenInEvent = true;
                                alert("Cannot shuffle: Scores have been partially entered for some matches in this event. Please clear these scores or reset the event if you wish to shuffle.");
                                return;
                            }
                        }
                    }
                    if (actionTakenInEvent) break;
                }
            }

            if (actionTakenInEvent) {
                alert("Cannot shuffle entries: Matches have been played or scores partially entered in this event. Please reset the event data if you wish to start over and shuffle.");
                return;
            }

            if (!confirm(`Are you sure you want to shuffle the entries for ${EVENT_CODES[currentEventId]}? This will reorder the initial seeding and clear any unplayed match pairings.`)) {
                return;
            }

            const teams = eventData.teams;
            // Fisher-Yates Shuffle
            for (let i = teams.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [teams[i], teams[j]] = [teams[j], teams[i]]; // Swap
            }

            // Reset draw match assignments and scores for the shuffled event
            function resetDrawMatchAssignments(draw) {
                if (draw && draw.rounds) {
                    draw.rounds.forEach(round => {
                        round.forEach(match => {
                            match.team1Id = null;
                            match.team2Id = null;
                            match.score1 = [];
                            match.score2 = [];
                            match.winnerId = null;
                            match.loserId = null;
                            match.isComplete = false;
                            match.isBye = false; 
                        });
                    });
                }
            }

            resetDrawMatchAssignments(eventData.mainDraw);
            resetDrawMatchAssignments(eventData.consolationDraw);

            saveData();
            renderCurrentEvent(); // This will re-populate and re-render draws
            alert(`${EVENT_CODES[currentEventId]} entries have been shuffled. Draws have been updated based on the new order.`);
        }


        // --- Draw Generation Logic ---
        function createMatchObject(id, round, matchInRound, team1Source = null, team2Source = null, isSF = false, isFinal = false, customLabel = "") {
            return {
                id, round, matchInRound, customLabel,
                team1Id: null, team2Id: null,
                team1Source, team2Source, 
                score1: [], score2: [],
                winnerId: null, loserId: null,
                isBye: false, isComplete: false,
                isSF, isFinal, 
                isOverallChampionship: false,
                isThirdPlacePlayoff: false, 
                loserFeedsToConsolationMatchId: null, 
                loserFeedsToSlotNumber: null, 
            };
        }

        function generateMainDrawStructure(eventId) {
            const rounds = [];
            const numTeams = TOTAL_TEAMS_PER_EVENT; 
            let teamsInRound = numTeams;
            let roundNum = 1;

            // R1: 16 matches
            let roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1, 
                    { type: 'seed', slot: i * 2 }, { type: 'seed', slot: i * 2 + 1 }, false, false, `MD R1.${i+1}`);
                match.loserFeedsToConsolationMatchId = `CD1.${Math.floor(i/2) + 1}`;
                match.loserFeedsToSlotNumber = (i % 2 === 0) ? 1 : 2; 
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; 

            // R2: 8 matches
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` }, false, false, `MD R2.${i+1}`);
                match.loserFeedsToConsolationMatchId = `CD2.${i + 1}`;
                match.loserFeedsToSlotNumber = 2; 
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; 

            // R3 (QF): 4 matches
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` }, false, false, `MD QF.${i+1}`);
                match.loserFeedsToConsolationMatchId = `CD4.${i + 1}`; 
                match.loserFeedsToSlotNumber = 2; 
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; 

            // R4 (SF): 2 matches (Best of 3)
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` },
                    true, false, `MD SF.${i+1}`); 
                match.loserFeedsToConsolationMatchId = `CD6.${i + 1}`; 
                match.loserFeedsToSlotNumber = 2; 
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; 

            // R5 (Final): 1 match (Best of 3)
            roundMatches = [];
            const mdFinal = createMatchObject(`M${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `M${roundNum-1}.1` }, { type: 'winner', matchId: `M${roundNum-1}.2` },
                false, true, `MD Final`); 
            roundMatches.push(mdFinal);
            rounds.push(roundMatches);
            roundNum++;

            // R6 (Overall Championship): 1 match (Best of 3)
            roundMatches = [];
            const overallChampMatch = createMatchObject(`M${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: 'M5.1' }, // Winner of MD Final
                { type: 'winner', matchId: 'CD7.1' }, // Winner of CD Final
                false, true, `Overall Championship`); // isFinal for Bo3 logic
            overallChampMatch.isOverallChampionship = true;
            roundMatches.push(overallChampMatch);
            rounds.push(roundMatches);
            
            return { rounds };
        }

        function generateConsolationDrawStructure(eventId) {
            const rounds = [];
            let roundNum = 1; 

            // CD-R1: 8 matches (for 16 L_M1)
            let roundMatches = [];
            for (let i = 0; i < 8; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'loser', matchId: `M1.${i*2+1}` }, 
                    { type: 'loser', matchId: `M1.${i*2+2}` }, 
                    false, false, `CD R1.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R2: 8 matches (8 W_C1 vs 8 L_M2)
            roundMatches = [];
            for (let i = 0; i < 8; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M2.${i+1}` }, 
                    false, false, `CD R2.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R3 (Play-down for 8 W_C2): 4 matches
            roundMatches = [];
            for (let i = 0; i < 4; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+2}` },
                    false, false, `CD R3.${i+1} (Playdown)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R4 (4 W_C3 vs 4 L_M3/QF): 4 matches
            roundMatches = [];
            for (let i = 0; i < 4; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M3.${i+1}` }, 
                    false, false, `CD R4.${i+1} (vs QFL)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R5 (Play-down for 4 W_C4): 2 matches
            roundMatches = [];
            for (let i = 0; i < 2; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+2}` },
                    false, false, `CD R5.${i+1} (Playdown)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R6 (2 W_C5 vs 2 L_M4/SF): 2 matches (CD Semis)
            roundMatches = [];
            for (let i = 0; i < 2; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M4.${i+1}` }, 
                    false, false, `CD SF.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R7 (Consolation Final): 1 match
            roundMatches = [];
            const cdFinal = createMatchObject(`CD${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `CD${roundNum-1}.1` },
                { type: 'winner', matchId: `CD${roundNum-1}.2` },
                false, true, `CD Final`); // isFinal for label, Bo3 for CD final
            roundMatches.push(cdFinal);
            rounds.push(roundMatches); roundNum++;

            // CD-R8 (Third Place Playoff): 1 match (single game)
            roundMatches = [];
            const thirdPlaceMatch = createMatchObject(`CD${roundNum}.1`, roundNum, 1,
                { type: 'loser', matchId: 'M5.1' }, // Loser of MD Final
                { type: 'loser', matchId: 'CD7.1' }, // Loser of CD Final
                false, false, `3rd Place Playoff`); 
            thirdPlaceMatch.isThirdPlacePlayoff = true;
            roundMatches.push(thirdPlaceMatch);
            rounds.push(roundMatches);

            return { rounds };
        }


        // --- UI Rendering ---
        function setupEventTabs() {
            const tabsContainer = document.getElementById('event-tabs');
            tabsContainer.innerHTML = ''; 
            Object.keys(EVENT_CODES).forEach(eventId => {
                const button = document.createElement('button');
                button.dataset.event = eventId;
                button.textContent = EVENT_CODES[eventId];
                if (eventId === currentEventId) button.classList.add('active');
                button.addEventListener('click', () => switchEventTab(eventId));
                tabsContainer.appendChild(button);
            });

            const tournamentContentEl = document.getElementById('tournament-content');
            tournamentContentEl.innerHTML = ''; 
            Object.keys(EVENT_CODES).forEach(eventId => {
                const eventDiv = document.createElement('div');
                eventDiv.id = `event-${eventId}-container`;
                eventDiv.classList.add('event-container');
                if (eventId === currentEventId) eventDiv.classList.add('active');
                
                eventDiv.innerHTML = `
                    <h2>${EVENT_CODES[eventId]}</h2>
                    <div id="team-setup-area-${eventId}" class="team-setup-area">
                        <h3>Team Names Entry</h3>
                        <div id="team-names-input-${eventId}" class="team-input-grid"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Main Draw</h3>
                        <div id="main-draw-${eventId}" class="draw"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Consolation Draw</h3>
                        <div id="consolation-draw-${eventId}" class="draw"></div>
                    </div>
                `;
                tournamentContentEl.appendChild(eventDiv);
            });
        }

        function switchEventTab(eventId) {
            currentEventId = eventId;
            document.querySelectorAll('#event-tabs button').forEach(btn => btn.classList.remove('active'));
            const currentButton = document.querySelector(`#event-tabs button[data-event="${eventId}"]`);
            if (currentButton) currentButton.classList.add('active');
            
            document.querySelectorAll('.event-container').forEach(container => container.classList.remove('active'));
            const currentContainer = document.getElementById(`event-${eventId}-container`);
            if (currentContainer) currentContainer.classList.add('active');
            renderCurrentEvent();
        }

        function renderCurrentEvent() {
            const eventData = tournamentData[currentEventId];
            if (!eventData) {
                console.warn(`No data found for event ${currentEventId}. Cannot render.`);
                 // Check if the container exists before trying to clear it
                const eventContainer = document.getElementById(`event-${currentEventId}-container`);
                if (eventContainer) {
                    eventContainer.innerHTML = `<h2>${EVENT_CODES[currentEventId] || currentEventId}</h2><p>Data for this event could not be loaded or is missing.</p>`;
                }
                return;
            }
            
            renderTeamSetupUI(currentEventId);
            populateAllDrawsForEvent(currentEventId); 
            renderDraw(eventData.mainDraw, `main-draw-${currentEventId}`, currentEventId, 'MD');
            renderDraw(eventData.consolationDraw, `consolation-draw-${currentEventId}`, currentEventId, 'CD');
        }

        function renderTeamSetupUI(eventId) {
            const container = document.getElementById(`team-names-input-${eventId}`);
            if (!container) return;
            container.innerHTML = '';
            const teams = tournamentData[eventId].teams;
            teams.forEach((team, index) => {
                const group = document.createElement('div');
                group.classList.add('team-input-group');
                const label = document.createElement('label');
                label.setAttribute('for', `team-name-${eventId}-${index}`);
                label.textContent = `Entry ${index + 1}:`; 
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `team-name-${eventId}-${index}`;
                input.dataset.teamId = team.id;
                input.value = team.name;
                group.appendChild(label);
                group.appendChild(input);
                container.appendChild(group);
            });
        }
        
        function saveAllTeamNamesFromUI() {
            let changesMade = false;
            Object.keys(EVENT_CODES).forEach(eventId => {
                const event = tournamentData[eventId];
                if (!event || !event.teams) return;
                event.teams.forEach((team, index) => {
                    const inputElement = document.getElementById(`team-name-${eventId}-${index}`);
                    if (inputElement && inputElement.value !== team.name) {
                        team.name = inputElement.value;
                        changesMade = true;
                    }
                });
            });

            if (changesMade) {
                saveData();
                renderCurrentEvent(); 
                alert("All team names saved!");
            } else {
                alert("No changes to team names detected.");
            }
        }

        function renderDraw(drawData, containerId, eventId, drawTypePrefix) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ''; 

            if (!drawData || !drawData.rounds || drawData.rounds.length === 0) {
                container.innerHTML = '<p style="padding:10px; color:#777;">Draw not generated yet or no matches.</p>';
                return;
            }

            drawData.rounds.forEach((roundMatches, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.classList.add('round');
                roundDiv.dataset.roundIndex = roundIndex;

                roundMatches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.classList.add('match');
                    matchDiv.id = `match-${eventId}-${match.id}`; 
                    
                    const team1Name = getTeamNameById(currentEventId, match.team1Id) || (match.team1Id === 'BYE' ? 'BYE' : 'TBD');
                    const team2Name = getTeamNameById(currentEventId, match.team2Id) || (match.team2Id === 'BYE' ? 'BYE' : 'TBD');
                    
                    let scoreInputs1 = '', scoreInputs2 = '';
                    
                    const isBo3 = (drawTypePrefix === 'MD' && (match.isSF || match.isFinal || match.isOverallChampionship)) || 
                                  (drawTypePrefix === 'CD' && match.isFinal && !match.isThirdPlacePlayoff);
                    const numGamesToPlay = isBo3 ? 3 : 1;

                    // Ensure scores arrays are initialized
                    match.score1 = match.score1 || [];
                    match.score2 = match.score2 || [];

                    for (let g = 0; g < numGamesToPlay; g++) {
                        scoreInputs1 += `<input type="number" class="score-input team1-game${g+1}" min="0" max="30" ${match.isComplete ? 'disabled' : ''} value="${match.score1[g] !== undefined && match.score1[g] !== null ? match.score1[g] : ''}" title="Game ${g+1} Score for ${team1Name}"> `;
                        scoreInputs2 += `<input type="number" class="score-input team2-game${g+1}" min="0" max="30" ${match.isComplete ? 'disabled' : ''} value="${match.score2[g] !== undefined && match.score2[g] !== null ? match.score2[g] : ''}" title="Game ${g+1} Score for ${team2Name}"> `;
                    }
                    
                    let matchLabel = match.customLabel || `${match.id}`;
                    if (isBo3 && match.customLabel && !match.customLabel.toLowerCase().includes("best of 3")) matchLabel += " (Best of 3)";


                    matchDiv.innerHTML = `
                        <div class="match-meta">${matchLabel}</div>
                        <div class="team ${match.winnerId === match.team1Id && match.isComplete ? 'winner' : (match.loserId === match.team1Id && match.isComplete ? 'loser' : '')}">
                            <span class="team-name">${team1Name}</span>
                            <span class="scores-container">${scoreInputs1}</span>
                        </div>
                        <div class="team ${match.winnerId === match.team2Id && match.isComplete ? 'winner' : (match.loserId === match.team2Id && match.isComplete ? 'loser' : '')}">
                            <span class="team-name">${team2Name}</span>
                            <span class="scores-container">${scoreInputs2}</span>
                        </div>
                        ${!match.isComplete && match.team1Id && match.team2Id && match.team1Id !== 'BYE' && match.team2Id !== 'BYE' ? 
                            `<button class="save-score" onclick="handleScoreSave('${currentEventId}', '${drawTypePrefix}', '${match.id}')">Save Score</button>` : ''}
                        ${match.isBye ? `<div class="bye">${getTeamNameById(currentEventId, match.winnerId)} advances (BYE)</div>` : ''}
                        ${match.isComplete && !match.isBye ? `<div class="match-complete-indicator">Winner: ${getTeamNameById(currentEventId, match.winnerId)}</div>` : ''}
                    `;
                    roundDiv.appendChild(matchDiv);
                });
                container.appendChild(roundDiv);
            });
        }

        function getTeamNameById(eventId, teamId) {
            if (!teamId) return 'TBD'; 
            if (teamId === 'BYE') return 'BYE';
            const event = tournamentData[eventId];
            if (!event || !event.teams) return teamId; 
            const team = event.teams.find(t => t.id === teamId);
            return team ? team.name : teamId; 
        }
        
        function findMatchById(eventId, drawTypePrefix, matchId) {
            const event = tournamentData[eventId];
            if (!event) return null;
            const draw = drawTypePrefix === 'MD' ? event.mainDraw : event.consolationDraw;
            if (!draw || !draw.rounds) return null;
            for (const round of draw.rounds) {
                const foundMatch = round.find(m => m.id === matchId);
                if (foundMatch) return foundMatch;
            }
            return null;
        }

        // --- Scoring Rules ---
        function checkGameWinner(s1, s2) {
            if (s1 === null || s2 === null || s1 === undefined || s2 === undefined || String(s1).trim() === '' || String(s2).trim() === '') return null; 

            const p1 = parseInt(s1);
            const p2 = parseInt(s2);
            
            if (isNaN(p1) || isNaN(p2)) return null;


            if (p1 === 30 && p1 > p2) return 1; 
            if (p2 === 30 && p2 > p1) return 2; 
            if (p1 < 30 && p2 < 30) { 
                if (p1 >= 21 && p1 >= p2 + 2) return 1; 
                if (p2 >= 21 && p2 >= p1 + 2) return 2; 
            }
            return null; 
        }

        // --- Score Handling and Advancement ---
        function handleScoreSave(eventId, drawTypePrefix, matchId) {
            const match = findMatchById(eventId, drawTypePrefix, matchId);
            if (!match) { console.error("Match not found:", matchId); return; }

            const isBo3 = (drawTypePrefix === 'MD' && (match.isSF || match.isFinal || match.isOverallChampionship)) || 
                          (drawTypePrefix === 'CD' && match.isFinal && !match.isThirdPlacePlayoff) ; 
            const numGamesToPlay = isBo3 ? 3 : 1;
            
            const collectedScores1 = [], collectedScores2 = [];
            const matchDiv = document.getElementById(`match-${eventId}-${match.id}`);
            if (!matchDiv) { console.error("Match div not found for scores:", `match-${eventId}-${match.id}`); return; }

            for (let g = 0; g < numGamesToPlay; g++) {
                const s1El = matchDiv.querySelector(`.team1-game${g+1}`);
                const s2El = matchDiv.querySelector(`.team2-game${g+1}`);
                if (!s1El || !s2El) { collectedScores1.push(null); collectedScores2.push(null); continue;}

                const s1Val = s1El.value;
                const s2Val = s2El.value;
                
                collectedScores1.push(s1Val === '' ? null : parseInt(s1Val));
                collectedScores2.push(s2Val === '' ? null : parseInt(s2Val));
            }
            match.score1 = collectedScores1; 
            match.score2 = collectedScores2;

            let team1MatchGamesWon = 0;
            let team2MatchGamesWon = 0;
            let allRequiredGamesValidlyScored = true;
            let gamesPlayedCount = 0; // For Bo3, count how many games were actually played/scored

            for (let g = 0; g < numGamesToPlay; g++) {
                if (isBo3 && (team1MatchGamesWon >= 2 || team2MatchGamesWon >= 2)) break; // Match already decided in Bo3

                const gameWinner = checkGameWinner(match.score1[g], match.score2[g]);
                if (gameWinner === 1) {
                    team1MatchGamesWon++;
                    gamesPlayedCount++;
                } else if (gameWinner === 2) {
                    team2MatchGamesWon++;
                    gamesPlayedCount++;
                } else {
                    // If a score is entered but it's not a valid win, it's an invalid game score
                    if (match.score1[g] !== null || match.score2[g] !== null) { 
                       allRequiredGamesValidlyScored = false;
                    }
                    // For Bo3, if we haven't reached 2 wins for either player, and this game is unscored,
                    // we might not have enough games yet, unless it's the first or second game of a Bo3.
                    // The logic below will handle if the match itself is complete.
                }
            }
            
            // Determine match winner
            let determinedWinnerId = null;
            if (!isBo3) { // Single game
                if (team1MatchGamesWon === 1) determinedWinnerId = match.team1Id;
                else if (team2MatchGamesWon === 1) determinedWinnerId = match.team2Id;
                else { allRequiredGamesValidlyScored = false; } // If no one won the single game
            } else { // Best of 3
                if (team1MatchGamesWon >= 2) determinedWinnerId = match.team1Id;
                else if (team2MatchGamesWon >= 2) determinedWinnerId = match.team2Id;
                else { allRequiredGamesValidlyScored = false; } // Not enough games won for a Bo3
            }
            
            if (!allRequiredGamesValidlyScored) {
                alert(`Match scores for ${match.id} are incomplete or invalid. For single games, one player must win (e.g. 21-10, or 30-29). For Best of 3, two games must be won with valid scores. Please check all entered scores.`);
                match.winnerId = null; 
                match.loserId = null;
                match.isComplete = false;
                // Do not save and re-render, let user correct.
                // We've already updated match.score1 and match.score2 in memory, so if they save again it will be with current inputs.
                saveData(); // Save the partially entered scores
                renderCurrentEvent(); // Re-render to show current state of inputs
                return;
            }
            
            match.winnerId = determinedWinnerId;
            match.loserId = (match.winnerId === match.team1Id) ? match.team2Id : match.team1Id;
            match.isComplete = true;

            if (!match.isOverallChampionship && !match.isThirdPlacePlayoff) {
                const loserTeamObj = tournamentData[eventId].teams.find(t => t.id === match.loserId);
                if (loserTeamObj) { 
                    if (drawTypePrefix === 'MD') {
                        loserTeamObj.mainDrawLosses = (loserTeamObj.mainDrawLosses || 0) + 1;
                    } else { 
                        loserTeamObj.consolationLosses = (loserTeamObj.consolationLosses || 0) + 1;
                    }
                }
            }
            
            saveData();
            renderCurrentEvent(); 
        }
        
        function populateAllDrawsForEvent(eventId) {
            const event = tournamentData[eventId];
            if (!event) return;
            
            let maxIterations = 7; // Max rounds in either draw is around this. Should be enough to propagate.
            let iteration = 0;
            let changedInIteration;

            do {
                changedInIteration = false;
                // Create a snapshot of team assignments to detect changes
                const snapshot = (draw) => draw && draw.rounds ? draw.rounds.map(r => r.map(m => `${m.id}:${m.team1Id}-${m.team2Id}:${m.isComplete}`)) : [];
                const originalAssignments = JSON.stringify({
                    md: snapshot(event.mainDraw),
                    cd: snapshot(event.consolationDraw)
                });

                populateSpecificDraw(eventId, event.mainDraw, 'MD');
                populateSpecificDraw(eventId, event.consolationDraw, 'CD');

                const newAssignments = JSON.stringify({
                    md: snapshot(event.mainDraw),
                    cd: snapshot(event.consolationDraw)
                });
                
                if (originalAssignments !== newAssignments) {
                    changedInIteration = true;
                }
                iteration++;
            } while (changedInIteration && iteration < maxIterations);
             if (iteration === maxIterations && changedInIteration) {
                console.warn("Max population iterations reached, but changes were still happening. Draw might not be fully stable. Check for circular dependencies or logic errors in player feeding.");
            }
        }


        function populateSpecificDraw(eventId, drawData, drawTypePrefix) {
            const event = tournamentData[eventId];
            if (!drawData || !drawData.rounds) return;

            drawData.rounds.forEach(round => {
                round.forEach(match => {
                    if (match.isComplete && !match.isBye) return; // Already completed, don't touch
                                                                
                    // Populate team1Id
                    if (!match.team1Id || match.team1Id === 'TBD') { 
                        const p1Id = getPlayerIdFromSource(eventId, match.team1Source); 
                        if (p1Id) match.team1Id = p1Id;
                    }
                    // Populate team2Id
                    if (!match.team2Id || match.team2Id === 'TBD') {
                        const p2Id = getPlayerIdFromSource(eventId, match.team2Source); 
                        if (p2Id) match.team2Id = p2Id;
                    }

                    // Auto-complete BYEs if not already marked as complete by a bye
                    if (!match.isComplete) { 
                        let newByeWinner = null;
                        if (match.team1Id === 'BYE' && match.team2Id && match.team2Id !== 'BYE' && match.team2Id !== 'TBD') {
                            newByeWinner = match.team2Id;
                        } else if (match.team2Id === 'BYE' && match.team1Id && match.team1Id !== 'BYE' && match.team1Id !== 'TBD') {
                            newByeWinner = match.team1Id;
                        } else if (match.team1Id === 'BYE' && match.team2Id === 'BYE') {
                            // This case ideally shouldn't happen if sources are TBD until one is resolved.
                            // If it does, winner is 'BYE' but it won't advance meaningfully.
                            newByeWinner = 'BYE'; 
                        }
                        
                        if (newByeWinner) {
                             match.winnerId = newByeWinner;
                             match.loserId = (newByeWinner === match.team1Id) ? match.team2Id : match.team1Id; 
                             match.isComplete = true;
                             match.isBye = true;
                             match.score1 = []; match.score2 = []; 
                        }
                    }

                    // Feed losers from MD to CD
                    if (drawTypePrefix === 'MD' && match.isComplete && match.loserId && match.loserFeedsToConsolationMatchId) {
                        const loserIdToFeed = match.loserId; 
                        const cdMatchToFeed = findMatchById(eventId, 'CD', match.loserFeedsToConsolationMatchId);

                        if (cdMatchToFeed && !cdMatchToFeed.isComplete) { 
                            let slotFilledThisIteration = false;
                            if (match.loserFeedsToSlotNumber === 1 && (!cdMatchToFeed.team1Id || cdMatchToFeed.team1Id === 'TBD')) {
                                cdMatchToFeed.team1Id = loserIdToFeed;
                                slotFilledThisIteration = true;
                            } else if (match.loserFeedsToSlotNumber === 2 && (!cdMatchToFeed.team2Id || cdMatchToFeed.team2Id === 'TBD')) {
                                cdMatchToFeed.team2Id = loserIdToFeed;
                                slotFilledThisIteration = true;
                            }

                            // If a slot was filled, check again for BYE completion in the CD match
                            if (slotFilledThisIteration && !cdMatchToFeed.isComplete) {
                                let cdByeWinner = null;
                                if (cdMatchToFeed.team1Id === 'BYE' && cdMatchToFeed.team2Id && cdMatchToFeed.team2Id !== 'BYE' && cdMatchToFeed.team2Id !== 'TBD') {
                                    cdByeWinner = cdMatchToFeed.team2Id;
                                } else if (cdMatchToFeed.team2Id === 'BYE' && cdMatchToFeed.team1Id && cdMatchToFeed.team1Id !== 'BYE' && cdMatchToFeed.team1Id !== 'TBD') {
                                    cdByeWinner = cdMatchToFeed.team1Id;
                                }
                                if (cdByeWinner) {
                                    cdMatchToFeed.winnerId = cdByeWinner;
                                    cdMatchToFeed.loserId = (cdByeWinner === cdMatchToFeed.team1Id) ? cdMatchToFeed.team2Id : cdMatchToFeed.team1Id;
                                    cdMatchToFeed.isComplete = true; cdMatchToFeed.isBye = true;
                                    cdMatchToFeed.score1 = []; cdMatchToFeed.score2 = [];
                                }
                            }
                        }
                    }
                });
            });
        }

        function getPlayerIdFromSource(eventId, source) { 
            if (!source) return null;
            const event = tournamentData[eventId];
            if (!event) return null; // Event data must exist

            if (source.type === 'seed') {
                // Ensure event.teams is defined and source.slot is a valid index
                if (event.teams && event.teams[source.slot]) {
                    return event.teams[source.slot].id;
                }
                // If slot is out of bounds (e.g. fewer than 32 teams if byes are possible from start)
                // or if byes are explicitly seeded, this could return 'BYE'.
                // For this system, we assume 32 distinct entries unless modified for byes.
                // Defaulting to 'BYE' if team not found at slot is risky without explicit BYE seeding.
                // Let's assume for now all slots map to a team or are handled by upstream logic.
                // If team truly doesn't exist, then TBD/null is better than assuming BYE here.
                return event.teams[source.slot] ? event.teams[source.slot].id : null; // or 'TBD'

            } else if (source.type === 'winner') {
                const sourceDrawType = source.matchId.startsWith('M') ? 'MD' : 'CD';
                const sourceMatch = findMatchById(eventId, sourceDrawType, source.matchId);
                if (sourceMatch && sourceMatch.isComplete) {
                    return sourceMatch.winnerId; 
                }
                return null; 
            } else if (source.type === 'loser') {
                const sourceDrawType = source.matchId.startsWith('M') ? 'MD' : 'CD';
                const sourceMatch = findMatchById(eventId, sourceDrawType, source.matchId);
                
                if (sourceMatch && sourceMatch.isComplete) {
                    // If the source match itself was a bye, the "loser" is effectively the BYE placeholder
                    // if the other team was real and advanced.
                    if (sourceMatch.isBye) {
                        if (sourceMatch.team1Id === 'BYE' && sourceMatch.winnerId === sourceMatch.team2Id) return 'BYE';
                        if (sourceMatch.team2Id === 'BYE' && sourceMatch.winnerId === sourceMatch.team1Id) return 'BYE';
                         // If winner is BYE (e.g. BYE vs BYE), loser is also BYE
                        if (sourceMatch.winnerId === 'BYE') return 'BYE';
                    }
                    return sourceMatch.loserId; 
                }
                return null; 
            }
            return null;
        }

        // --- Entry Point ---
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>
