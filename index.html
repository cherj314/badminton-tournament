<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton Tournament</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; margin: 0; padding: 20px; background-color: #f0f2f5; color: #1c1e21; font-size: 14px; }
        header { background-color: #4A90E2; color: white; padding: 15px 20px; text-align: center; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        header h1 { margin: 0; font-size: 1.8em; }
        nav#event-tabs { margin-top: 10px; }
        nav#event-tabs button { padding: 10px 15px; margin: 0 5px; cursor: pointer; background-color: #357ABD; color: white; border: none; border-radius: 5px; font-size: 0.9em; transition: background-color 0.2s; }
        nav#event-tabs button:hover { background-color: #2A5C8D; }
        nav#event-tabs button.active { background-color: #1E4263; font-weight: bold; }
        
        #tournament-controls { text-align: center; margin-bottom: 20px; padding: 10px; background-color: #fff; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        #tournament-controls button { padding: 10px 18px; margin: 5px; cursor: pointer; color: white; border: none; border-radius: 5px; font-size: 0.95em; transition: background-color 0.2s, box-shadow 0.2s; }
        #tournament-controls button#save-all-teams { background-color: #4CAF50; } /* Green */
        #tournament-controls button#save-all-teams:hover { background-color: #45a049; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#reset-tournament { background-color: #f44336; } /* Red */
        #tournament-controls button#reset-tournament:hover { background-color: #e53935; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }

        .event-container { display: none; margin-top: 20px; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .event-container.active { display: block; }
        .event-container h2 { color: #4A90E2; margin-top:0; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;}

        #team-setup-area { margin-bottom: 25px; padding: 15px; background-color: #f9f9f9; border-radius: 6px; }
        #team-setup-area h3 { margin-top: 0; color: #333; }
        .team-input-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 10px; }
        .team-input-group { display: flex; align-items: center; background-color: #fff; padding: 8px; border: 1px solid #ddd; border-radius:4px;}
        .team-input-group label { display: inline-block; width: 100px; font-size: 0.9em; color: #555; margin-right: 5px; }
        .team-input-group input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex-grow:1; font-size: 0.9em;}
        
        .draw-section h3 { border-bottom: 2px solid #4A90E2; padding-bottom: 8px; margin-top: 25px; margin-bottom: 15px; color: #1E4263;}
        .draw { display: flex; flex-direction: row; overflow-x: auto; padding: 15px 5px; background-color: #fdfdfd; border: 1px solid #e0e0e0; border-radius: 6px; min-height: 350px;}
        .round { display: flex; flex-direction: column; justify-content: space-around; margin-right: 15px; padding: 0 10px; min-width: 280px; border-right: 1px dashed #d0d0d0; }
        .round:last-child { border-right: none; }
        .match { background-color: #ffffff; border: 1px solid #cccccc; border-radius: 6px; padding: 12px; margin: 12px 0; position: relative; box-shadow: 0 1px 3px rgba(0,0,0,0.08); transition: box-shadow 0.2s;}
        .match:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.12); }
        .match .team { display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #eee; }
        .match .team:last-child { border-bottom: none; }
        .match .team-name { flex-grow: 1; font-size: 0.95em; color: #333; }
        .match .scores-container { display: flex; }
        .match .score-input { width: 38px; padding: 5px; text-align: center; margin-left: 4px; border: 1px solid #bbb; border-radius: 3px; font-size: 0.9em;}
        .match .match-meta { font-size: 0.75em; color: #666; margin-bottom: 6px; text-align: right; }
        .match button.save-score { padding: 8px 12px; font-size: 0.9em; background-color: #5cb85c; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; display: block; width: 100%; transition: background-color 0.2s;}
        .match button.save-score:hover { background-color: #4cae4c; }
        .match .winner .team-name { font-weight: bold; color: #007bff; } /* Changed winner color */
        .match .loser .team-name { text-decoration: line-through; color: #777; }
        .bye { font-style: italic; color: #555; text-align: center; padding: 15px; background-color: #f8f9fa; border-radius: 4px; margin-top: 5px;}
        .match-complete-indicator { font-weight: bold; color: #28a745; margin-top: 5px; text-align: center; font-size:0.85em; }

        #loading-status { text-align: center; padding: 12px; background-color: #ffc107; color: #333; border-radius: 5px; margin-bottom:15px; font-weight:500;}
    </style>
</head>
<body>
    <header>
        <h1>Badminton Tournament Manager</h1>
        <nav id="event-tabs"></nav>
    </header>

    <div id="tournament-controls">
        <button id="save-all-teams">Save All Team Names</button>
        <button id="reset-tournament">Reset Tournament Data</button>
        <p id="loading-status" style="display:none;">Loading data...</p>
    </div>

    <div id="tournament-content">
        </div>

    <script>
        const EVENT_CODES = {
            BS: "Boy's Singles", GS: "Girl's Singles",
            BD: "Boy's Doubles", GD: "Girl's Doubles",
            XD: "Mixed Doubles"
        };
        const NUM_SCHOOLS = 16;
        const TEAMS_PER_SCHOOL = 2;
        const TOTAL_TEAMS_PER_EVENT = NUM_SCHOOLS * TEAMS_PER_SCHOOL; // 32

        let tournamentData = {};
        let currentEventId = 'BS'; // Default active event

        // --- Initialization and Data Persistence ---
        function initApp() {
            loadData();
            setupEventTabs(); // Ensure tabs are set up before rendering
            renderCurrentEvent(); // Render the default active event
            document.getElementById('reset-tournament').addEventListener('click', resetTournamentData);
            document.getElementById('save-all-teams').addEventListener('click', saveAllTeamNamesFromUI);
        }

        function saveData() {
            try {
                localStorage.setItem('badmintonTournamentData_v2', JSON.stringify(tournamentData)); // Added _v2 for potential versioning
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
                alert("Could not save data. LocalStorage might be full or disabled.");
            }
        }

        function loadData() {
            const statusEl = document.getElementById('loading-status');
            if(statusEl) statusEl.style.display = 'block';
            try {
                const storedData = localStorage.getItem('badmintonTournamentData_v2');
                if (storedData) {
                    tournamentData = JSON.parse(storedData);
                    Object.keys(EVENT_CODES).forEach(eventId => { // Ensure all defined events exist
                        if (!tournamentData[eventId]) {
                            tournamentData[eventId] = createEventObject(eventId);
                        } else { // Basic migration/check for existing data structures
                            if (!tournamentData[eventId].teams || tournamentData[eventId].teams.length !== TOTAL_TEAMS_PER_EVENT) {
                                tournamentData[eventId].teams = createInitialTeams(eventId);
                            }
                            if (!tournamentData[eventId].mainDraw || !tournamentData[eventId].mainDraw.rounds) {
                                tournamentData[eventId].mainDraw = generateMainDrawStructure(eventId);
                            }
                            if (!tournamentData[eventId].consolationDraw || !tournamentData[eventId].consolationDraw.rounds) {
                                tournamentData[eventId].consolationDraw = generateConsolationDrawStructure(eventId);
                            }
                        }
                    });
                } else {
                    initializeNewTournament();
                }
            } catch (e) {
                console.error("Error loading data from localStorage:", e);
                initializeNewTournament(); // Fallback to new tournament on error
            }
            if(statusEl) statusEl.style.display = 'none';
        }
        
        function initializeNewTournament() {
            tournamentData = {};
            Object.keys(EVENT_CODES).forEach(eventId => {
                tournamentData[eventId] = createEventObject(eventId);
            });
            saveData();
        }

        function createEventObject(eventId) {
            return {
                id: eventId,
                name: EVENT_CODES[eventId],
                teams: createInitialTeams(eventId),
                mainDraw: generateMainDrawStructure(eventId),
                consolationDraw: generateConsolationDrawStructure(eventId),
                setupComplete: false 
            };
        }

        function createInitialTeams(eventId) {
            const teams = [];
            for (let i = 0; i < NUM_SCHOOLS; i++) {
                for (let j = 0; j < TEAMS_PER_SCHOOL; j++) {
                    const teamId = `${eventId}_s${i+1}_t${j+1}`;
                    teams.push({
                        id: teamId,
                        name: `School ${i+1} - Team ${j+1}`,
                        originalPlayerSlot: teams.length, // 0 to 31
                        mainDrawLosses: 0,
                        consolationLosses: 0
                    });
                }
            }
            return teams;
        }

        function resetTournamentData() {
            if (confirm("Are you sure you want to reset all tournament data? This cannot be undone.")) {
                localStorage.removeItem('badmintonTournamentData_v2');
                initializeNewTournament();
                renderCurrentEvent(); 
                alert("Tournament data has been reset.");
            }
        }

        // --- Draw Generation Logic ---
        function createMatchObject(id, round, matchInRound, team1Source = null, team2Source = null, isSF = false, isFinal = false, customLabel = "") {
            return {
                id, round, matchInRound, customLabel,
                team1Id: null, team2Id: null,
                team1Source, team2Source, // {type: 'seed'/'winner'/'loser', matchId: 'M1.1', slot: 0/1}
                score1: [], score2: [],
                winnerId: null, loserId: null,
                isBye: false, isComplete: false,
                isSF, isFinal, // For Bo3 games
                loserFeedsToConsolationMatchId: null, // For MD matches
                loserFeedsToSlotNumber: null, // 1 or 2 for team1/team2 in CD match
            };
        }

        function generateMainDrawStructure(eventId) {
            const rounds = [];
            const numTeams = TOTAL_TEAMS_PER_EVENT; // 32
            let teamsInRound = numTeams;
            let roundNum = 1;

            // R1: 16 matches
            let roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1, 
                    { type: 'seed', slot: i * 2 }, { type: 'seed', slot: i * 2 + 1 });
                // Losers of R1 feed CD-R1
                match.loserFeedsToConsolationMatchId = `CD1.${i + 1}`;
                match.loserFeedsToSlotNumber = (i % 2 === 0) ? 1 : 2; // Alternate slots for visual balance
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; // 16 teams left

            // R2: 8 matches
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` });
                // Losers of R2 feed CD-R2
                match.loserFeedsToConsolationMatchId = `CD2.${i + 1}`;
                match.loserFeedsToSlotNumber = 2; // Let CD R1 winners take slot 1
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; // 8 teams left (QF)

            // R3 (QF): 4 matches
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` });
                // Losers of QF feed CD-R4 (after CD-R3 playdown)
                match.loserFeedsToConsolationMatchId = `CD4.${i + 1}`;
                match.loserFeedsToSlotNumber = 2; // Let CD R3 winners take slot 1
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; // 4 teams left (SF)

            // R4 (SF): 2 matches (Best of 3)
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` },
                    true, false); // isSF=true
                // Losers of SF feed CD-R6 (after CD-R5 playdown)
                match.loserFeedsToConsolationMatchId = `CD6.${i + 1}`;
                match.loserFeedsToSlotNumber = 2; // Let CD R5 winners take slot 1
                roundMatches.push(match);
            }
            rounds.push(roundMatches);
            teamsInRound /= 2; roundNum++; // 2 teams left (Final)

            // R5 (Final): 1 match (Best of 3)
            roundMatches = [];
            roundMatches.push(createMatchObject(`M${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `M${roundNum-1}.1` }, { type: 'winner', matchId: `M${roundNum-1}.2` },
                false, true)); // isFinal=true
            rounds.push(roundMatches);
            
            return { rounds };
        }

        function generateConsolationDrawStructure(eventId) {
            const rounds = [];
            let roundNum = 1;

            // CD-R1: 8 matches (16 L_M1)
            let roundMatches = [];
            for (let i = 0; i < 8; i++) {
                // Source for these will be set by MD loserFeedsTo...
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'loser', matchId: `M1.${i*2+1}` }, // Placeholder, will be set by MD
                    { type: 'loser', matchId: `M1.${i*2+2}` }, // Placeholder
                     false, false, "CD R1"));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R2: 8 matches (8 W_C1 vs 8 L_M2)
            roundMatches = [];
            for (let i = 0; i < 8; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M2.${i+1}` }, // Placeholder
                    false, false, "CD R2"));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R3A (Play-down for 8 W_C2): 4 matches
            roundMatches = [];
            for (let i = 0; i < 4; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}A.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+2}` },
                    false, false, "CD R3 Playdown"));
            }
            rounds.push(roundMatches); // Still roundNum 3 conceptually for W_C2 playdown

            // CD-R4 (4 W_C3A vs 4 L_M3/QF): 4 matches
            let nextConsolationRoundNum = roundNum + 1;
            roundMatches = [];
            for (let i = 0; i < 4; i++) {
                roundMatches.push(createMatchObject(`CD${nextConsolationRoundNum}.${i+1}`, nextConsolationRoundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum}A.${i+1}` },
                    { type: 'loser', matchId: `M3.${i+1}` }, // Placeholder for QF losers
                    false, false, "CD R4 (vs QFL)"));
            }
            rounds.push(roundMatches); roundNum = nextConsolationRoundNum + 1;

            // CD-R5A (Play-down for 4 W_C4): 2 matches
            roundMatches = [];
            for (let i = 0; i < 2; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}A.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+2}` },
                    false, false, "CD R5 Playdown"));
            }
            rounds.push(roundMatches);

            // CD-R6 (2 W_C5A vs 2 L_M4/SF): 2 matches
            nextConsolationRoundNum = roundNum + 1;
            roundMatches = [];
            for (let i = 0; i < 2; i++) {
                roundMatches.push(createMatchObject(`CD${nextConsolationRoundNum}.${i+1}`, nextConsolationRoundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum}A.${i+1}` },
                    { type: 'loser', matchId: `M4.${i+1}` }, // Placeholder for SF losers
                    false, false, "CD Semi-Finals"));
            }
            rounds.push(roundMatches); roundNum = nextConsolationRoundNum + 1;

            // CD-R7 (Consolation Final): 1 match
            roundMatches = [];
            roundMatches.push(createMatchObject(`CD${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `CD${roundNum-1}.1` },
                { type: 'winner', matchId: `CD${roundNum-1}.2` },
                false, true, "CD Final")); // isFinal=true for label, not Bo3 unless specified
            rounds.push(roundMatches);

            return { rounds };
        }


        // --- UI Rendering ---
        function setupEventTabs() {
            const tabsContainer = document.getElementById('event-tabs');
            tabsContainer.innerHTML = ''; 
            Object.keys(EVENT_CODES).forEach(eventId => {
                const button = document.createElement('button');
                button.dataset.event = eventId;
                button.textContent = EVENT_CODES[eventId];
                if (eventId === currentEventId) button.classList.add('active');
                button.addEventListener('click', () => switchEventTab(eventId));
                tabsContainer.appendChild(button);
            });

            const tournamentContentEl = document.getElementById('tournament-content');
            tournamentContentEl.innerHTML = ''; 
            Object.keys(EVENT_CODES).forEach(eventId => {
                const eventDiv = document.createElement('div');
                eventDiv.id = `event-${eventId}-container`;
                eventDiv.classList.add('event-container');
                if (eventId === currentEventId) eventDiv.classList.add('active');
                
                eventDiv.innerHTML = `
                    <h2>${EVENT_CODES[eventId]}</h2>
                    <div id="team-setup-area-${eventId}" class="team-setup-area">
                        <h3>Team Names Entry</h3>
                        <div id="team-names-input-${eventId}" class="team-input-grid"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Main Draw</h3>
                        <div id="main-draw-${eventId}" class="draw"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Consolation Draw</h3>
                        <div id="consolation-draw-${eventId}" class="draw"></div>
                    </div>
                `;
                tournamentContentEl.appendChild(eventDiv);
            });
        }

        function switchEventTab(eventId) {
            currentEventId = eventId;
            document.querySelectorAll('#event-tabs button').forEach(btn => btn.classList.remove('active'));
            const currentButton = document.querySelector(`#event-tabs button[data-event="${eventId}"]`);
            if (currentButton) currentButton.classList.add('active');
            
            document.querySelectorAll('.event-container').forEach(container => container.classList.remove('active'));
            const currentContainer = document.getElementById(`event-${eventId}-container`);
            if (currentContainer) currentContainer.classList.add('active');
            renderCurrentEvent();
        }

        function renderCurrentEvent() {
            const eventData = tournamentData[currentEventId];
            if (!eventData) return;
            
            renderTeamSetupUI(currentEventId);
            populateAllDrawsForEvent(currentEventId); // Populate first
            renderDraw(eventData.mainDraw, `main-draw-${currentEventId}`, currentEventId, 'MD');
            renderDraw(eventData.consolationDraw, `consolation-draw-${currentEventId}`, currentEventId, 'CD');
        }

        function renderTeamSetupUI(eventId) {
            const container = document.getElementById(`team-names-input-${eventId}`);
            if (!container) return;
            container.innerHTML = '';
            const teams = tournamentData[eventId].teams;
            teams.forEach((team, index) => {
                const group = document.createElement('div');
                group.classList.add('team-input-group');
                const label = document.createElement('label');
                label.setAttribute('for', `team-name-${eventId}-${index}`);
                label.textContent = `Entry ${index + 1}:`; // Generic "Entry"
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `team-name-${eventId}-${index}`;
                input.dataset.teamId = team.id;
                input.value = team.name;
                group.appendChild(label);
                group.appendChild(input);
                container.appendChild(group);
            });
        }
        
        function saveAllTeamNamesFromUI() {
            let changesMade = false;
            Object.keys(EVENT_CODES).forEach(eventId => {
                const event = tournamentData[eventId];
                if (!event || !event.teams) return;
                event.teams.forEach((team, index) => {
                    const inputElement = document.getElementById(`team-name-${eventId}-${index}`);
                    if (inputElement && inputElement.value !== team.name) {
                        team.name = inputElement.value;
                        changesMade = true;
                    }
                });
            });

            if (changesMade) {
                saveData();
                renderCurrentEvent(); 
                alert("All team names saved!");
            } else {
                alert("No changes to team names detected.");
            }
        }

        function renderDraw(drawData, containerId, eventId, drawTypePrefix) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ''; 

            if (!drawData || !drawData.rounds || drawData.rounds.length === 0) {
                container.innerHTML = '<p style="padding:10px; color:#777;">Draw not generated yet or no matches.</p>';
                return;
            }

            drawData.rounds.forEach((roundMatches, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.classList.add('round');
                roundDiv.dataset.roundIndex = roundIndex;

                roundMatches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.classList.add('match');
                    matchDiv.id = `match-${eventId}-${match.id}`; // Ensure unique DOM ID
                    
                    const team1Name = getTeamNameById(currentEventId, match.team1Id) || (match.team1Id === 'BYE' ? 'BYE' : 'TBD');
                    const team2Name = getTeamNameById(currentEventId, match.team2Id) || (match.team2Id === 'BYE' ? 'BYE' : 'TBD');
                    
                    let scoreInputs1 = '', scoreInputs2 = '';
                    const numGamesToPlay = (match.isSF || match.isFinal) ? 3 : 1; // Main Draw SF/Final are Bo3

                    for (let g = 0; g < numGamesToPlay; g++) {
                        scoreInputs1 += `<input type="number" class="score-input team1-game${g+1}" min="0" max="30" ${match.isComplete ? 'disabled' : ''} value="${match.score1[g] !== undefined ? match.score1[g] : ''}" title="Game ${g+1} Score for ${team1Name}"> `;
                        scoreInputs2 += `<input type="number" class="score-input team2-game${g+1}" min="0" max="30" ${match.isComplete ? 'disabled' : ''} value="${match.score2[g] !== undefined ? match.score2[g] : ''}" title="Game ${g+1} Score for ${team2Name}"> `;
                    }
                    
                    let matchLabel = match.customLabel || `${match.id}`;
                    if (match.isSF) matchLabel += " (MD SF - Bo3)";
                    if (match.isFinal) matchLabel += " (MD Final - Bo3)";
                    if (match.id.startsWith("CD") && match.isFinal) matchLabel += " (CD Final)";


                    matchDiv.innerHTML = `
                        <div class="match-meta">${matchLabel}</div>
                        <div class="team ${match.winnerId === match.team1Id && match.isComplete ? 'winner' : (match.loserId === match.team1Id && match.isComplete ? 'loser' : '')}">
                            <span class="team-name">${team1Name}</span>
                            <span class="scores-container">${scoreInputs1}</span>
                        </div>
                        <div class="team ${match.winnerId === match.team2Id && match.isComplete ? 'winner' : (match.loserId === match.team2Id && match.isComplete ? 'loser' : '')}">
                            <span class="team-name">${team2Name}</span>
                            <span class="scores-container">${scoreInputs2}</span>
                        </div>
                        ${!match.isComplete && match.team1Id && match.team2Id && match.team1Id !== 'BYE' && match.team2Id !== 'BYE' ? 
                            `<button class="save-score" onclick="handleScoreSave('${currentEventId}', '${drawTypePrefix}', '${match.id}')">Save Score</button>` : ''}
                        ${match.isBye ? `<div class="bye">${getTeamNameById(currentEventId, match.winnerId)} advances (BYE)</div>` : ''}
                        ${match.isComplete && !match.isBye ? `<div class="match-complete-indicator">Winner: ${getTeamNameById(currentEventId, match.winnerId)}</div>` : ''}
                    `;
                    roundDiv.appendChild(matchDiv);
                });
                container.appendChild(roundDiv);
            });
        }

        function getTeamNameById(eventId, teamId) {
            if (!teamId) return null;
            if (teamId === 'BYE') return 'BYE';
            const event = tournamentData[eventId];
            if (!event || !event.teams) return teamId; 
            const team = event.teams.find(t => t.id === teamId);
            return team ? team.name : teamId; // Fallback to ID
        }
        
        function findMatchById(eventId, drawTypePrefix, matchId) {
            const event = tournamentData[eventId];
            const draw = drawTypePrefix === 'MD' ? event.mainDraw : event.consolationDraw;
            for (const round of draw.rounds) {
                const foundMatch = round.find(m => m.id === matchId);
                if (foundMatch) return foundMatch;
            }
            return null;
        }

        // --- Score Handling and Advancement ---
        function handleScoreSave(eventId, drawTypePrefix, matchId) {
            const match = findMatchById(eventId, drawTypePrefix, matchId);
            if (!match) { console.error("Match not found:", matchId); return; }

            const numGamesToPlay = (match.isSF || match.isFinal) ? 3 : 1;
            const scores1 = [], scores2 = [];
            
            const matchDiv = document.getElementById(`match-${eventId}-${match.id}`);
            if (!matchDiv) { console.error("Match div not found for scores:", `match-${eventId}-${match.id}`); return; }


            for (let g = 0; g < numGamesToPlay; g++) {
                const s1El = matchDiv.querySelector(`.team1-game${g+1}`);
                const s2El = matchDiv.querySelector(`.team2-game${g+1}`);
                if (!s1El || !s2El) { alert(`Score input elements for Game ${g+1} not found.`); return; }

                const s1 = parseInt(s1El.value);
                const s2 = parseInt(s2El.value);

                // Collect all entered scores, even if not a full game.
                if (!isNaN(s1)) scores1.push(s1); else scores1.push(null);
                if (!isNaN(s2)) scores2.push(s2); else scores2.push(null);
            }
            match.score1 = scores1.filter(s => s !== null); // Store only entered scores
            match.score2 = scores2.filter(s => s !== null);

            let team1GamesWon = 0;
            let team2GamesWon = 0;
            let gameWinnerDetermined = true;

            for (let g = 0; g < numGamesToPlay; g++) {
                const s1 = match.score1[g];
                const s2 = match.score2[g];

                if (s1 === undefined || s2 === undefined || s1 === null || s2 === null) { // Game not fully scored
                    if (g < team1GamesWon + team2GamesWon) continue; // Already won/lost this game as part of match outcome
                    gameWinnerDetermined = false; 
                    break;
                }

                if ((s1 >= 21 || s2 >= 21) && 
                    ( (s1 >= s2 + 2 && s1 < 30) || (s2 >= s1 + 2 && s2 < 30) || (s1 === 30 && s1 > s2) || (s2 === 30 && s2 > s1) || (s1 === 21 && s2 < 20 && numGamesToPlay ===1) || (s2 === 21 && s1 < 20 && numGamesToPlay ===1))) {
                    if (s1 > s2) team1GamesWon++;
                    else team2GamesWon++;
                } else if (s1 === 20 && s2 === 20 && numGamesToPlay > 1 ) { // 20-all rule
                     gameWinnerDetermined = false; break; // Needs more points
                } else if ( (s1 < 21 && s2 < 21) && numGamesToPlay === 1 ) {
                     gameWinnerDetermined = false; break; // Single game not finished
                } else if (Math.abs(s1-s2) < 2 && (s1 >=20 || s2 >=20) && s1 < 29 && s2 < 29) {
                     gameWinnerDetermined = false; break; // Needs to win by 2
                } else if (s1 < 21 && s2 < 21 && (team1GamesWon <2 && team2GamesWon <2 && numGamesToPlay ===3)) {
                    // In Bo3, if one game is like 15-10, it's not complete.
                    gameWinnerDetermined = false; break;
                }
            }

            if (!gameWinnerDetermined && !( (numGamesToPlay === 3 && (team1GamesWon >= 2 || team2GamesWon >=2)) || (numGamesToPlay === 1 && (team1GamesWon >=1 || team2GamesWon >=1)) )) {
                alert(`Match scores for ${match.id} are incomplete or invalid under badminton rules (win by 2, cap 30 for games to 21). Please check scores for all games.`);
                return;
            }

            if (numGamesToPlay === 1) {
                if (team1GamesWon === 1) match.winnerId = match.team1Id;
                else if (team2GamesWon === 1) match.winnerId = match.team2Id;
                else { alert("Single game match winner could not be determined."); return; }
            } else { // Best of 3
                if (team1GamesWon >= 2) match.winnerId = match.team1Id;
                else if (team2GamesWon >= 2) match.winnerId = match.team2Id;
                else { alert("Best of 3 match winner could not be determined. Two games must be won."); return; }
            }
            
            match.loserId = (match.winnerId === match.team1Id) ? match.team2Id : match.team1Id;
            match.isComplete = true;

            // Update team loss counts
            const loserTeamObj = tournamentData[eventId].teams.find(t => t.id === match.loserId);
            if (loserTeamObj) {
                if (drawTypePrefix === 'MD') loserTeamObj.mainDrawLosses++;
                else loserTeamObj.consolationLosses++;
            }
            
            saveData();
            renderCurrentEvent(); // Re-render to show updates & propagate
        }
        
        function populateAllDrawsForEvent(eventId) {
            const event = tournamentData[eventId];
            if (!event) return;
            
            // Populate Main Draw first, as its outcomes feed Consolation
            populateSpecificDraw(eventId, event.mainDraw, 'MD');
            // Then populate Consolation Draw
            populateSpecificDraw(eventId, event.consolationDraw, 'CD');
        }


        function populateSpecificDraw(eventId, drawData, drawTypePrefix) {
            const event = tournamentData[eventId];
            if (!drawData || !drawData.rounds) return;

            drawData.rounds.forEach(round => {
                round.forEach(match => {
                    if (match.isComplete) return; // Don't re-process completed matches

                    // Populate team1Id
                    if (!match.team1Id && match.team1Source) {
                        match.team1Id = getPlayerIdFromSource(eventId, match.team1Source);
                    }
                    // Populate team2Id
                    if (!match.team2Id && match.team2Source) {
                        match.team2Id = getPlayerIdFromSource(eventId, match.team2Source);
                    }

                    // Auto-complete BYEs
                    if (!match.isComplete && (match.team1Id === 'BYE' || match.team2Id === 'BYE')) {
                        if (match.team1Id === 'BYE' && match.team2Id && match.team2Id !== 'BYE') {
                            match.winnerId = match.team2Id;
                        } else if (match.team2Id === 'BYE' && match.team1Id && match.team1Id !== 'BYE') {
                            match.winnerId = match.team1Id;
                        } else if (match.team1Id === 'BYE' && match.team2Id === 'BYE') {
                             // Should not happen with proper seeding if total teams is even.
                             // Or could mean no player available for either slot. For now, treat as no match.
                             match.winnerId = 'BYE'; // Or null, effectively a double walkover
                        }
                        if (match.winnerId) {
                             match.isComplete = true;
                             match.isBye = true;
                             match.score1 = [0]; match.score2 = [0]; // Nominal score for bye
                             // Loser of a bye match (the BYE itself) doesn't feed consolation.
                        }
                    }

                    // Handle MD loser feeding to CD
                    if (drawTypePrefix === 'MD' && match.isComplete && match.loserId && match.loserId !== 'BYE') {
                        const loserTeam = event.teams.find(t => t.id === match.loserId);
                        // Only feed if it's the first loss in MD
                        if (loserTeam && loserTeam.mainDrawLosses === 1) { 
                            const cdMatchToFeed = findMatchById(eventId, 'CD', match.loserFeedsToConsolationMatchId);
                            if (cdMatchToFeed && !cdMatchToFeed.isComplete) {
                                if (match.loserFeedsToSlotNumber === 1 && !cdMatchToFeed.team1Id) {
                                    cdMatchToFeed.team1Id = match.loserId;
                                } else if (match.loserFeedsToSlotNumber === 2 && !cdMatchToFeed.team2Id) {
                                    cdMatchToFeed.team2Id = match.loserId;
                                }
                                // Check if the CD match now has both players and one is a BYE (from upstream)
                                if(cdMatchToFeed.team1Id && cdMatchToFeed.team2Id === 'BYE') {
                                    cdMatchToFeed.winnerId = cdMatchToFeed.team1Id;
                                    cdMatchToFeed.isComplete = true; cdMatchToFeed.isBye = true;
                                } else if (cdMatchToFeed.team2Id && cdMatchToFeed.team1Id === 'BYE') {
                                    cdMatchToFeed.winnerId = cdMatchToFeed.team2Id;
                                    cdMatchToFeed.isComplete = true; cdMatchToFeed.isBye = true;
                                }
                            }
                        }
                    }
                });
            });
        }

        function getPlayerIdFromSource(eventId, source) {
            if (!source) return null;
            const event = tournamentData[eventId];

            if (source.type === 'seed') {
                return event.teams[source.slot] ? event.teams[source.slot].id : 'BYE'; // Assign BYE if team slot is out of bounds
            } else if (source.type === 'winner') {
                const sourceDrawType = source.matchId.startsWith('M') ? 'MD' : 'CD';
                const sourceMatch = findMatchById(eventId, sourceDrawType, source.matchId);
                return sourceMatch && sourceMatch.isComplete ? sourceMatch.winnerId : null;
            } else if (source.type === 'loser') { // This is mainly for CD structure definition, actual feeding handled by MD match completion
                const sourceDrawType = source.matchId.startsWith('M') ? 'MD' : 'CD';
                const sourceMatch = findMatchById(eventId, sourceDrawType, source.matchId);
                // Check if this player has already lost in CD, if so, they are out.
                if (sourceMatch && sourceMatch.isComplete && sourceMatch.loserId) {
                    const loserTeam = event.teams.find(t => t.id === sourceMatch.loserId);
                    if (sourceDrawType === 'CD' && loserTeam && loserTeam.consolationLosses > 0) {
                        return null; // Already eliminated from CD
                    }
                    return sourceMatch.loserId;
                }
                return null;
            }
            return null;
        }

        // --- Entry Point ---
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>
