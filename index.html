<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton Tournament Manager</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; margin: 0; padding: 20px; background-color: #f0f2f5; color: #1c1e21; font-size: 14px; }
        header { background-color: #4A90E2; color: white; padding: 15px 20px; text-align: center; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        header h1 { margin: 0; font-size: 1.8em; }
        nav#event-tabs { margin-top: 10px; }
        nav#event-tabs button { padding: 10px 15px; margin: 0 5px; cursor: pointer; background-color: #357ABD; color: white; border: none; border-radius: 5px; font-size: 0.9em; transition: background-color 0.2s; }
        nav#event-tabs button:hover { background-color: #2A5C8D; }
        nav#event-tabs button.active { background-color: #1E4263; font-weight: bold; }
        
        #tournament-controls { text-align: center; margin-bottom: 20px; padding: 10px; background-color: #fff; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        #tournament-controls button { padding: 10px 18px; margin: 5px; cursor: pointer; color: white; border: none; border-radius: 5px; font-size: 0.95em; transition: background-color 0.2s, box-shadow 0.2s; }
        #tournament-controls button#save-all-teams { background-color: #4CAF50; } /* Green */
        #tournament-controls button#save-all-teams:hover { background-color: #45a049; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#shuffle-current-event-teams { background-color: #FF9800; } /* Orange */
        #tournament-controls button#shuffle-current-event-teams:hover { background-color: #FB8C00; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#reset-tournament { background-color: #f44336; } /* Red */
        #tournament-controls button#reset-tournament:hover { background-color: #e53935; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#export-data { background-color: #007bff; } /* Blue */
        #tournament-controls button#export-data:hover { background-color: #0069d9; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #tournament-controls button#import-data { background-color: #17a2b8; } /* Teal */
        #tournament-controls button#import-data:hover { background-color: #138496; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }

        .event-container { display: none; margin-top: 20px; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .event-container.active { display: block; }
        .event-container h2 { color: #4A90E2; margin-top:0; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;}

        .team-setup-area { margin-bottom: 25px; padding: 15px; background-color: #f9f9f9; border-radius: 6px; }
        .team-setup-area h3 { margin-top: 0; color: #333; }
        .team-input-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 10px; }
        .team-input-group { display: flex; align-items: center; background-color: #fff; padding: 8px; border: 1px solid #ddd; border-radius:4px;}
        .team-input-group label { display: inline-block; width: 100px; font-size: 0.9em; color: #555; margin-right: 5px; }
        .team-input-group input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex-grow:1; font-size: 0.9em;}
        
        .draw-section h3 { border-bottom: 2px solid #4A90E2; padding-bottom: 8px; margin-top: 25px; margin-bottom: 15px; color: #1E4263;}
        .draw { display: flex; flex-direction: row; overflow-x: auto; padding: 15px 5px; background-color: #fdfdfd; border: 1px solid #e0e0e0; border-radius: 6px; min-height: 350px;}
        .round { display: flex; flex-direction: column; justify-content: space-around; margin-right: 15px; padding: 0 10px; min-width: 280px; border-right: 1px dashed #d0d0d0; }
        .round:last-child { border-right: none; }
        .match { background-color: #ffffff; border: 1px solid #cccccc; border-radius: 6px; padding: 12px; margin: 12px 0; position: relative; box-shadow: 0 1px 3px rgba(0,0,0,0.08); transition: box-shadow 0.2s;}
        .match:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.12); }
        .match .team { display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #eee; }
        .match .team:last-child { border-bottom: none; }
        .match .team-name { flex-grow: 1; font-size: 0.95em; color: #333; }
        .match .scores-container { display: flex; }
        .match .score-input { width: 38px; padding: 5px; text-align: center; margin-left: 4px; border: 1px solid #bbb; border-radius: 3px; font-size: 0.9em;}
        .match .match-meta { font-size: 0.75em; color: #666; margin-bottom: 6px; text-align: right; }
        .match button.save-score { padding: 8px 12px; font-size: 0.9em; background-color: #5cb85c; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; display: block; width: 100%; transition: background-color 0.2s;}
        .match button.save-score:hover { background-color: #4cae4c; }
        .match .winner .team-name { font-weight: bold; color: #007bff; } 
        .match .loser .team-name { text-decoration: line-through; color: #777; }
        .bye { font-style: italic; color: #555; text-align: center; padding: 15px; background-color: #f8f9fa; border-radius: 4px; margin-top: 5px;}
        .match-complete-indicator { font-weight: bold; color: #28a745; margin-top: 5px; text-align: center; font-size:0.85em; }

        #loading-status { text-align: center; padding: 12px; background-color: #ffc107; color: #333; border-radius: 5px; margin-bottom:15px; font-weight:500;}
    </style>
</head>
<body>
    <header>
        <h1>Badminton Tournament Manager</h1>
        <nav id="event-tabs"></nav>
    </header>

    <div id="tournament-controls">
        <button id="save-all-teams">Save All Team Names</button>
        <button id="shuffle-current-event-teams">Shuffle Current Event Entries</button>
        <button id="reset-tournament">Reset Tournament Data</button>
        <button id="export-data">Export Tournament Data (JSON)</button>
        <button id="import-data">Import Tournament Data (JSON)</button>
        <input type="file" id="import-file-input" accept=".json" style="display: none;">
        <p id="loading-status" style="display:none;">Loading data...</p>
    </div>

    <div id="tournament-content">
        </div>

    <script>
        const EVENT_CODES = {
            BS: "Boy's Singles", GS: "Girl's Singles",
            BD: "Boy's Doubles", GD: "Girl's Doubles",
            XD: "Mixed Doubles"
        };
        const NUM_SCHOOLS = 16;
        const TEAMS_PER_SCHOOL = 2;
        const TOTAL_TEAMS_PER_EVENT = NUM_SCHOOLS * TEAMS_PER_SCHOOL; // 32
        const LOCAL_STORAGE_KEY = 'badmintonTournamentData_v3.3'; // Updated version for new shuffle logic

        let tournamentData = {};
        let currentEventId = 'BS'; // Default active event

        // --- Initialization and Data Persistence ---
        function initApp() {
            loadData();
            setupEventTabs(); 
            renderCurrentEvent(); 
            document.getElementById('reset-tournament').addEventListener('click', resetTournamentData);
            document.getElementById('save-all-teams').addEventListener('click', saveAllTeamNamesFromUI);
            document.getElementById('shuffle-current-event-teams').addEventListener('click', shuffleCurrentEventTeams);
            document.getElementById('export-data').addEventListener('click', exportTournamentData);
            document.getElementById('import-data').addEventListener('click', () => {
                document.getElementById('import-file-input').click();
            });
            document.getElementById('import-file-input').addEventListener('change', handleTournamentDataUpload);
        }

        function saveData() {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(tournamentData)); 
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
                alert("Could not save data. LocalStorage might be full or disabled.");
            }
        }

        function loadData() {
            const statusEl = document.getElementById('loading-status');
            if(statusEl) statusEl.style.display = 'block';
            try {
                const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (storedData) {
                    tournamentData = JSON.parse(storedData);
                    Object.keys(EVENT_CODES).forEach(eventId => { 
                        if (!tournamentData[eventId]) {
                            tournamentData[eventId] = createEventObject(eventId);
                        } else { 
                            if (!tournamentData[eventId].teams || !Array.isArray(tournamentData[eventId].teams) || tournamentData[eventId].teams.length !== TOTAL_TEAMS_PER_EVENT) {
                                tournamentData[eventId].teams = createInitialTeams(eventId);
                            }
                            const mdRounds = tournamentData[eventId].mainDraw && tournamentData[eventId].mainDraw.rounds;
                            if (!mdRounds || !Array.isArray(mdRounds) || mdRounds.length < 6) { // 5 rounds + 1 overall final
                                tournamentData[eventId].mainDraw = generateMainDrawStructure(eventId);
                            }
                            const cdRounds = tournamentData[eventId].consolationDraw && tournamentData[eventId].consolationDraw.rounds;
                            if (!cdRounds || !Array.isArray(cdRounds) || cdRounds.length < 8) { // 7 rounds + 1 third place
                                tournamentData[eventId].consolationDraw = generateConsolationDrawStructure(eventId);
                            }
                            // Ensure waterfall consolation draw structure
                            const wfcdRounds = tournamentData[eventId].waterfallConsolationDraw && tournamentData[eventId].waterfallConsolationDraw.rounds;
                            if (!wfcdRounds || !Array.isArray(wfcdRounds) || wfcdRounds.length < 3) { // 2 rounds + 1 final for WCD
                                tournamentData[eventId].waterfallConsolationDraw = generateWaterfallConsolationDrawStructure(eventId);
                            }
                        }
                    });
                } else {
                    initializeNewTournament();
                }
            } catch (e) {
                console.error("Error loading data from localStorage:", e);
                initializeNewTournament(); 
            }
            if(statusEl) statusEl.style.display = 'none';
        }
        
        function initializeNewTournament() {
            tournamentData = {};
            Object.keys(EVENT_CODES).forEach(eventId => {
                tournamentData[eventId] = createEventObject(eventId);
            });
            saveData();
        }

        function createEventObject(eventId) {
            return {
                id: eventId,
                name: EVENT_CODES[eventId],
                teams: createInitialTeams(eventId),
                mainDraw: generateMainDrawStructure(eventId),
                consolationDraw: generateConsolationDrawStructure(eventId),
                waterfallConsolationDraw: generateWaterfallConsolationDrawStructure(eventId), // Added
                setupComplete: false 
            };
        }

        function createInitialTeams(eventId) {
            const teams = [];
            for (let i = 0; i < NUM_SCHOOLS; i++) {
                for (let j = 0; j < TEAMS_PER_SCHOOL; j++) {
                    const teamId = `${eventId}_s${i+1}_t${j+1}`;
                    teams.push({
                        id: teamId,
                        name: `School ${i+1} - Team ${j+1}`,
                        originalPlayerSlot: teams.length, 
                        mainDrawLosses: 0,
                        consolationLosses: 0
                        // waterfallConsolationLosses: 0 // Not strictly needed for current logic
                    });
                }
            }
            return teams;
        }

        function resetTournamentData() {
            if (confirm("Are you sure you want to reset all tournament data? This cannot be undone.")) {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                initializeNewTournament();
                renderCurrentEvent(); 
                alert("Tournament data has been reset.");
            }
        }

        // --- Import/Export Feature ---
        function exportTournamentData() {
            try {
                const jsonData = JSON.stringify(tournamentData, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, "-");
                a.download = `badminton_tournament_data_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert("Tournament data exported successfully!");
            } catch (e) {
                console.error("Error exporting data:", e);
                alert("Could not export data. See console for details.");
            }
        }

        function handleTournamentDataUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!confirm("Importing data will overwrite any existing tournament data. Are you sure you want to proceed?")) {
                event.target.value = null; return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedRawData = JSON.parse(e.target.result);
                    const validatedData = {};
                    let importSuccessful = true;

                    Object.keys(EVENT_CODES).forEach(appEventId => {
                        if (importedRawData[appEventId]) {
                            const eventData = JSON.parse(JSON.stringify(importedRawData[appEventId]));

                            if (!eventData.teams || !Array.isArray(eventData.teams) || eventData.teams.length !== TOTAL_TEAMS_PER_EVENT) {
                                console.warn(`Teams for event ${appEventId} are missing or malformed. Re-initializing.`);
                                eventData.teams = createInitialTeams(appEventId);
                            } else {
                                eventData.teams.forEach((team, index) => {
                                    if (typeof team.id !== 'string' || typeof team.name !== 'string') {
                                        console.warn(`Team ${index} in event ${appEventId} malformed. Re-initializing all teams.`);
                                        eventData.teams = createInitialTeams(appEventId); return;
                                    }
                                    team.mainDrawLosses = team.mainDrawLosses || 0;
                                    team.consolationLosses = team.consolationLosses || 0;
                                });
                            }

                            const mdRounds = eventData.mainDraw && eventData.mainDraw.rounds;
                            if (!mdRounds || !Array.isArray(mdRounds) || mdRounds.length < 6) {
                                console.warn(`Main draw for ${appEventId} malformed. Re-generating.`);
                                eventData.mainDraw = generateMainDrawStructure(appEventId);
                            }

                            const cdRounds = eventData.consolationDraw && eventData.consolationDraw.rounds;
                            if (!cdRounds || !Array.isArray(cdRounds) || cdRounds.length < 8) {
                                console.warn(`Consolation draw for ${appEventId} malformed. Re-generating.`);
                                eventData.consolationDraw = generateConsolationDrawStructure(appEventId);
                            }
                            
                            const wfcdRounds = eventData.waterfallConsolationDraw && eventData.waterfallConsolationDraw.rounds;
                            if (!wfcdRounds || !Array.isArray(wfcdRounds) || wfcdRounds.length < 3) {
                                console.warn(`Waterfall Consolation draw for ${appEventId} missing or malformed. Re-generating.`);
                                eventData.waterfallConsolationDraw = generateWaterfallConsolationDrawStructure(appEventId);
                            }
                            
                            [eventData.mainDraw, eventData.consolationDraw, eventData.waterfallConsolationDraw].forEach(draw => {
                                if (draw && draw.rounds) {
                                    draw.rounds.forEach(round => {
                                        round.forEach(match => {
                                            if (!Array.isArray(match.score1)) match.score1 = [];
                                            if (!Array.isArray(match.score2)) match.score2 = [];
                                            match.isComplete = !!match.isComplete;
                                            match.isBye = !!match.isBye;
                                        });
                                    });
                                }
                            });
                            validatedData[appEventId] = eventData;
                        } else {
                            console.warn(`Event ${appEventId} not in imported data. Initializing as new.`);
                            validatedData[appEventId] = createEventObject(appEventId);
                        }
                    });
                    
                    if (Object.keys(validatedData).length === 0 && Object.keys(EVENT_CODES).length > 0) {
                        alert("Import failed: No recognizable tournament data for configured events.");
                        importSuccessful = false;
                    }

                    if (importSuccessful) {
                        tournamentData = validatedData;
                        saveData();
                        alert("Tournament data imported successfully! The page will now refresh.");
                        
                        const statusEl = document.getElementById('loading-status');
                        if(statusEl) statusEl.style.display = 'block';
                        
                        setupEventTabs(); 
                        
                        let firstEventId = Object.keys(EVENT_CODES)[0];
                        if (!EVENT_CODES[currentEventId] || !tournamentData[currentEventId]) {
                            currentEventId = firstEventId;
                        }
                        switchEventTab(currentEventId);

                        if(statusEl) statusEl.style.display = 'none';
                    }
                } catch (e) {
                    console.error("Error processing imported JSON file:", e);
                    alert("Failed to import data. File might be corrupted or not in correct JSON format.");
                } finally {
                    event.target.value = null; 
                }
            };
            reader.onerror = function() {
                alert("Error reading the file."); event.target.value = null;
            };
            reader.readAsText(file);
        }

        // --- Shuffle Feature ---
        // Helper function to get school number and team rank (1 or 2) from team ID
        function getSchoolAndTeamRank(teamId) {
            const match = teamId.match(/_s(\d+)_t(\d+)$/);
            if (match) {
                return {
                    schoolNum: parseInt(match[1]),
                    teamRank: parseInt(match[2])
                };
            }
            console.error("Could not parse school/team rank from ID:", teamId);
            return { schoolNum: -1, teamRank: -1 }; // Should ideally not happen
        }

        // Standard Fisher-Yates shuffle
        function fyShuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        function shuffleCurrentEventTeams() {
            const eventData = tournamentData[currentEventId];
            if (!eventData) { alert("No event selected or data not found."); return; }

            let actionTakenInEvent = false;
            const drawsToCheck = [eventData.mainDraw, eventData.consolationDraw, eventData.waterfallConsolationDraw];

            for (const draw of drawsToCheck) {
                if (draw && draw.rounds) {
                    for (const round of draw.rounds) {
                        for (const match of round) {
                            if (match.isComplete && !match.isBye) { actionTakenInEvent = true; break; }
                            const hasEnteredScores = (m) => (m.score1 && m.score1.some(s => s !== null && s !== undefined && String(s).trim() !== '')) || (m.score2 && m.score2.some(s => s !== null && s !== undefined && String(s).trim() !== ''));
                            if (!match.isComplete && hasEnteredScores(match) && match.team1Id && match.team2Id && match.team1Id !== 'BYE' && match.team2Id !== 'BYE') {
                                actionTakenInEvent = true;
                                alert("Cannot shuffle: Scores partially entered. Clear scores or reset event."); return;
                            }
                        }
                    }
                    if (actionTakenInEvent) break;
                }
            }

            if (actionTakenInEvent) { alert("Cannot shuffle: Matches played or scores entered. Reset event to shuffle."); return; }
            if (!confirm(`Shuffle entries for ${EVENT_CODES[currentEventId]}? This reorders seeding and clears unplayed matches, applying new placement rules.`)) return;

            const originalTeams = [...eventData.teams]; // Work with a copy initially
            const team1sList = [];
            const team2sList = [];

            originalTeams.forEach(team => {
                const { teamRank } = getSchoolAndTeamRank(team.id);
                if (teamRank === 1) {
                    team1sList.push(team);
                } else if (teamRank === 2) {
                    team2sList.push(team);
                }
            });

            fyShuffle(team1sList);
            fyShuffle(team2sList);

            const finalArrangement = new Array(TOTAL_TEAMS_PER_EVENT);
            const HALF_SIZE = TOTAL_TEAMS_PER_EVENT / 2; // 16
            const TEAMS_OF_TYPE_PER_HALF = NUM_SCHOOLS / 2; // 8

            let topHalfSlots = Array.from({ length: HALF_SIZE }, (_, i) => i); // 0-15
            let bottomHalfSlots = Array.from({ length: HALF_SIZE }, (_, i) => i + HALF_SIZE); // 16-31
            fyShuffle(topHalfSlots);
            fyShuffle(bottomHalfSlots);

            const schoolTeam1Location = {}; // { schoolNum: 'top' | 'bottom' }

            // Place Team 1s: 8 in top half, 8 in bottom half
            for (let i = 0; i < TEAMS_OF_TYPE_PER_HALF; i++) {
                const team1_top = team1sList[i];
                const slot_top = topHalfSlots.pop();
                finalArrangement[slot_top] = team1_top;
                const { schoolNum: schoolNum_top } = getSchoolAndTeamRank(team1_top.id);
                schoolTeam1Location[schoolNum_top] = 'top';
            }
            for (let i = 0; i < TEAMS_OF_TYPE_PER_HALF; i++) {
                const team1_bottom = team1sList[TEAMS_OF_TYPE_PER_HALF + i];
                const slot_bottom = bottomHalfSlots.pop();
                finalArrangement[slot_bottom] = team1_bottom;
                const { schoolNum: schoolNum_bottom } = getSchoolAndTeamRank(team1_bottom.id);
                schoolTeam1Location[schoolNum_bottom] = 'bottom';
            }
            
            // Place Team 2s based on their Team 1's location
            team2sList.forEach(team2 => {
                const { schoolNum } = getSchoolAndTeamRank(team2.id);
                if (schoolTeam1Location[schoolNum] === 'top') { // Team 1 is in top, so Team 2 goes to bottom
                    if (bottomHalfSlots.length === 0) {
                        console.error("Error: No bottom half slots left for Team 2. This shouldn't happen.");
                        // Fallback: try to place anywhere, though logic should prevent this
                        const fallbackSlot = finalArrangement.indexOf(undefined);
                        if (fallbackSlot !== -1) finalArrangement[fallbackSlot] = team2;
                        return;
                    }
                    const slot = bottomHalfSlots.pop();
                    finalArrangement[slot] = team2;
                } else { // Team 1 is in bottom, so Team 2 goes to top
                     if (topHalfSlots.length === 0) {
                        console.error("Error: No top half slots left for Team 2. This shouldn't happen.");
                        const fallbackSlot = finalArrangement.indexOf(undefined);
                        if (fallbackSlot !== -1) finalArrangement[fallbackSlot] = team2;
                        return;
                    }
                    const slot = topHalfSlots.pop();
                    finalArrangement[slot] = team2;
                }
            });
            
            // Verify the arrangement (optional debug)
            // let topT1=0, topT2=0, botT1=0, botT2=0;
            // finalArrangement.forEach((team, idx) => {
            //     if (!team) { console.error("UNDEFINED TEAM at index", idx); return; }
            //     const {teamRank} = getSchoolAndTeamRank(team.id);
            //     if (idx < HALF_SIZE) { // Top half
            //         if (teamRank === 1) topT1++; else topT2++;
            //     } else { // Bottom half
            //         if (teamRank === 1) botT1++; else botT2++;
            //     }
            // });
            // console.log(`Top: T1=${topT1}, T2=${topT2}. Bottom: T1=${botT1}, T2=${botT2}`);
            // For N=16 schools: should be Top: T1=8, T2=8. Bottom: T1=8, T2=8.

            eventData.teams = finalArrangement;


            function resetDrawMatchAssignments(draw) {
                if (draw && draw.rounds) {
                    draw.rounds.forEach(round => {
                        round.forEach(match => {
                            match.team1Id = null; match.team2Id = null;
                            match.score1 = []; match.score2 = [];
                            match.winnerId = null; match.loserId = null;
                            match.isComplete = false; match.isBye = false; 
                        });
                    });
                }
            }

            resetDrawMatchAssignments(eventData.mainDraw);
            resetDrawMatchAssignments(eventData.consolationDraw);
            resetDrawMatchAssignments(eventData.waterfallConsolationDraw);

            saveData();
            renderCurrentEvent();
            alert(`${EVENT_CODES[currentEventId]} entries shuffled according to new rules. Draws updated.`);
        }


        // --- Draw Generation Logic ---
        function createMatchObject(id, round, matchInRound, team1Source = null, team2Source = null, 
                                   isSF = false, isFinal = false, customLabel = "",
                                   loserFeedsToNextBracketMatchId = null, loserFeedsToNextBracketSlotNumber = null, nextBracketType = null) {
            return {
                id, round, matchInRound, customLabel,
                team1Id: null, team2Id: null,
                team1Source, team2Source, 
                score1: [], score2: [],
                winnerId: null, loserId: null,
                isBye: false, isComplete: false,
                isSF, isFinal, 
                isOverallChampionship: false,
                isThirdPlacePlayoff: false, 
                loserFeedsToNextBracketMatchId, 
                loserFeedsToNextBracketSlotNumber,
                nextBracketType
            };
        }

        function generateMainDrawStructure(eventId) {
            const rounds = [];
            const numTeams = TOTAL_TEAMS_PER_EVENT; 
            let teamsInRound = numTeams;
            let roundNum = 1;

            // R1: 16 matches
            let roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1, 
                    { type: 'seed', slot: i * 2 }, { type: 'seed', slot: i * 2 + 1 }, 
                    false, false, `MD R1.${i+1}`,
                    `CD1.${Math.floor(i/2) + 1}`, (i % 2 === 0) ? 1 : 2, 'CD');
                roundMatches.push(match);
            }
            rounds.push(roundMatches); teamsInRound /= 2; roundNum++; 

            // R2: 8 matches
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` }, 
                    false, false, `MD R2.${i+1}`,
                    `CD2.${i + 1}`, 2, 'CD'); // Loser feeds to slot 2 of CD2 match
                roundMatches.push(match);
            }
            rounds.push(roundMatches); teamsInRound /= 2; roundNum++; 

            // R3 (QF): 4 matches
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` }, 
                    false, false, `MD QF.${i+1}`,
                    `CD4.${i + 1}`, 2, 'CD'); // Loser feeds to slot 2 of CD4 match
                roundMatches.push(match);
            }
            rounds.push(roundMatches); teamsInRound /= 2; roundNum++; 

            // R4 (SF): 2 matches (Best of 3)
            roundMatches = [];
            for (let i = 0; i < teamsInRound / 2; i++) {
                const match = createMatchObject(`M${roundNum}.${i+1}`, roundNum, i + 1,
                    { type: 'winner', matchId: `M${roundNum-1}.${i*2+1}` }, { type: 'winner', matchId: `M${roundNum-1}.${i*2+2}` },
                    true, false, `MD SF.${i+1}`,
                    `CD6.${i + 1}`, 2, 'CD'); // Loser feeds to slot 2 of CD6 match
                roundMatches.push(match);
            }
            rounds.push(roundMatches); teamsInRound /= 2; roundNum++; 

            // R5 (Final): 1 match (Best of 3)
            roundMatches = [];
            const mdFinal = createMatchObject(`M${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `M${roundNum-1}.1` }, { type: 'winner', matchId: `M${roundNum-1}.2` },
                false, true, `MD Final`); 
            roundMatches.push(mdFinal);
            rounds.push(roundMatches); roundNum++;

            // R6 (Overall Championship): 1 match (Best of 3)
            roundMatches = [];
            const overallChampMatch = createMatchObject(`M${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: 'M5.1' }, // Winner of MD Final
                { type: 'winner', matchId: 'CD7.1' }, // Winner of CD Final
                false, true, `Overall Championship`);
            overallChampMatch.isOverallChampionship = true;
            roundMatches.push(overallChampMatch);
            rounds.push(roundMatches);
            
            return { rounds };
        }

        function generateConsolationDrawStructure(eventId) {
            const rounds = [];
            let roundNum = 1; 

            // CD-R1: 8 matches (for 16 L_M1) - Losers feed to WCD R1
            let roundMatches = [];
            for (let i = 0; i < 8; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'loser', matchId: `M1.${i*2+1}` }, 
                    { type: 'loser', matchId: `M1.${i*2+2}` }, 
                    false, false, `CD R1.${i+1}`,
                    `WCD1.${Math.floor(i/2) + 1}`, (i % 2 === 0) ? 1 : 2, 'WCD')); // Feed to WCD
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R2: 8 matches (8 W_C1 vs 8 L_M2)
            roundMatches = [];
            for (let i = 0; i < 8; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M2.${i+1}` }, 
                    false, false, `CD R2.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R3 (Play-down for 8 W_C2): 4 matches
            roundMatches = [];
            for (let i = 0; i < 4; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+2}` },
                    false, false, `CD R3.${i+1} (Playdown)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R4 (4 W_C3 vs 4 L_M3/QF): 4 matches
            roundMatches = [];
            for (let i = 0; i < 4; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M3.${i+1}` }, 
                    false, false, `CD R4.${i+1} (vs QFL)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R5 (Play-down for 4 W_C4): 2 matches
            roundMatches = [];
            for (let i = 0; i < 2; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1, 
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `CD${roundNum-1}.${i*2+2}` },
                    false, false, `CD R5.${i+1} (Playdown)`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R6 (2 W_C5 vs 2 L_M4/SF): 2 matches (CD Semis)
            roundMatches = [];
            for (let i = 0; i < 2; i++) {
                roundMatches.push(createMatchObject(`CD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `CD${roundNum-1}.${i+1}` },
                    { type: 'loser', matchId: `M4.${i+1}` }, 
                    false, false, `CD SF.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // CD-R7 (Consolation Final): 1 match
            roundMatches = [];
            const cdFinal = createMatchObject(`CD${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `CD${roundNum-1}.1` },
                { type: 'winner', matchId: `CD${roundNum-1}.2` },
                false, true, `CD Final`); // isFinal for label, Bo3 for CD final
            roundMatches.push(cdFinal);
            rounds.push(roundMatches); roundNum++;

            // CD-R8 (Third Place Playoff): 1 match (single game)
            roundMatches = [];
            const thirdPlaceMatch = createMatchObject(`CD${roundNum}.1`, roundNum, 1,
                { type: 'loser', matchId: 'M5.1' }, // Loser of MD Final
                { type: 'loser', matchId: 'CD7.1' }, // Loser of CD Final
                false, false, `3rd Place Playoff`); 
            thirdPlaceMatch.isThirdPlacePlayoff = true;
            roundMatches.push(thirdPlaceMatch);
            rounds.push(roundMatches);

            return { rounds };
        }

        function generateWaterfallConsolationDrawStructure(eventId) {
            const rounds = [];
            let roundNum = 1;
            const numFeeders = 8; // Losers from CD R1 (8 matches -> 8 losers)

            // WCD-R1: 4 matches (for 8 L_CD1)
            let roundMatches = [];
            for (let i = 0; i < numFeeders / 2; i++) { // 4 matches
                roundMatches.push(createMatchObject(`WCD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'loser', matchId: `CD1.${i*2+1}` }, // Loser of CD1.1, CD1.3, CD1.5, CD1.7
                    { type: 'loser', matchId: `CD1.${i*2+2}` }, // Loser of CD1.2, CD1.4, CD1.6, CD1.8
                    false, false, `WCD R1.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // WCD-R2 (SF): 2 matches
            roundMatches = [];
            for (let i = 0; i < (numFeeders / 2) / 2; i++) { // 2 matches
                roundMatches.push(createMatchObject(`WCD${roundNum}.${i+1}`, roundNum, i+1,
                    { type: 'winner', matchId: `WCD${roundNum-1}.${i*2+1}` },
                    { type: 'winner', matchId: `WCD${roundNum-1}.${i*2+2}` },
                    false, false, `WCD SF.${i+1}`));
            }
            rounds.push(roundMatches); roundNum++;

            // WCD-R3 (Final): 1 match
            roundMatches = [];
            const wcdFinal = createMatchObject(`WCD${roundNum}.1`, roundNum, 1,
                { type: 'winner', matchId: `WCD${roundNum-1}.1` },
                { type: 'winner', matchId: `WCD${roundNum-1}.2` },
                false, false, `WCD Final`); // Assuming single game, isFinal=false unless Bo3 needed
            roundMatches.push(wcdFinal);
            rounds.push(roundMatches);

            return { rounds };
        }


        // --- UI Rendering ---
        function setupEventTabs() {
            const tabsContainer = document.getElementById('event-tabs');
            tabsContainer.innerHTML = ''; 
            Object.keys(EVENT_CODES).forEach(eventId => {
                const button = document.createElement('button');
                button.dataset.event = eventId;
                button.textContent = EVENT_CODES[eventId];
                if (eventId === currentEventId) button.classList.add('active');
                button.addEventListener('click', () => switchEventTab(eventId));
                tabsContainer.appendChild(button);
            });

            const tournamentContentEl = document.getElementById('tournament-content');
            tournamentContentEl.innerHTML = ''; 
            Object.keys(EVENT_CODES).forEach(eventId => {
                const eventDiv = document.createElement('div');
                eventDiv.id = `event-${eventId}-container`;
                eventDiv.classList.add('event-container');
                if (eventId === currentEventId) eventDiv.classList.add('active');
                
                eventDiv.innerHTML = `
                    <h2>${EVENT_CODES[eventId]}</h2>
                    <div id="team-setup-area-${eventId}" class="team-setup-area">
                        <h3>Team Names Entry</h3>
                        <div id="team-names-input-${eventId}" class="team-input-grid"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Main Draw</h3>
                        <div id="main-draw-${eventId}" class="draw"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Consolation Draw</h3>
                        <div id="consolation-draw-${eventId}" class="draw"></div>
                    </div>
                    <div class="draw-section">
                        <h3>Waterfall Consolations</h3>
                        <div id="waterfall-consolation-draw-${eventId}" class="draw"></div>
                    </div>
                `;
                tournamentContentEl.appendChild(eventDiv);
            });
        }

        function switchEventTab(eventId) {
            currentEventId = eventId;
            document.querySelectorAll('#event-tabs button').forEach(btn => btn.classList.remove('active'));
            const currentButton = document.querySelector(`#event-tabs button[data-event="${eventId}"]`);
            if (currentButton) currentButton.classList.add('active');
            
            document.querySelectorAll('.event-container').forEach(container => container.classList.remove('active'));
            const currentContainer = document.getElementById(`event-${eventId}-container`);
            if (currentContainer) currentContainer.classList.add('active');
            renderCurrentEvent();
        }

        function renderCurrentEvent() {
            const eventData = tournamentData[currentEventId];
            if (!eventData) {
                console.warn(`No data found for event ${currentEventId}. Cannot render.`);
                const eventContainer = document.getElementById(`event-${currentEventId}-container`);
                if (eventContainer) {
                    eventContainer.innerHTML = `<h2>${EVENT_CODES[currentEventId] || currentEventId}</h2><p>Data for this event could not be loaded or is missing.</p>`;
                }
                return;
            }
            
            renderTeamSetupUI(currentEventId);
            populateAllDrawsForEvent(currentEventId); 
            renderDraw(eventData.mainDraw, `main-draw-${currentEventId}`, currentEventId, 'MD');
            renderDraw(eventData.consolationDraw, `consolation-draw-${currentEventId}`, currentEventId, 'CD');
            renderDraw(eventData.waterfallConsolationDraw, `waterfall-consolation-draw-${currentEventId}`, currentEventId, 'WCD'); // Added
        }

        function renderTeamSetupUI(eventId) {
            const container = document.getElementById(`team-names-input-${eventId}`);
            if (!container) return;
            container.innerHTML = '';
            const teams = tournamentData[eventId].teams;
            teams.forEach((team, index) => {
                const group = document.createElement('div');
                group.classList.add('team-input-group');
                const label = document.createElement('label');
                label.setAttribute('for', `team-name-${eventId}-${index}`);
                label.textContent = `Entry ${index + 1}:`; 
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `team-name-${eventId}-${index}`;
                input.dataset.teamId = team.id;
                input.value = team.name;
                group.appendChild(label);
                group.appendChild(input);
                container.appendChild(group);
            });
        }
        
        function saveAllTeamNamesFromUI() {
            let changesMade = false;
            Object.keys(EVENT_CODES).forEach(eventId => {
                const event = tournamentData[eventId];
                if (!event || !event.teams) return;
                event.teams.forEach((team, index) => {
                    const inputElement = document.getElementById(`team-name-${eventId}-${index}`);
                    if (inputElement && inputElement.value !== team.name) {
                        team.name = inputElement.value;
                        changesMade = true;
                    }
                });
            });

            if (changesMade) {
                saveData();
                renderCurrentEvent(); 
                alert("All team names saved!");
            } else {
                alert("No changes to team names detected.");
            }
        }

        function renderDraw(drawData, containerId, eventId, drawTypePrefix) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ''; 

            if (!drawData || !drawData.rounds || drawData.rounds.length === 0) {
                container.innerHTML = '<p style="padding:10px; color:#777;">Draw not generated yet or no matches.</p>';
                return;
            }

            drawData.rounds.forEach((roundMatches, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.classList.add('round');
                roundDiv.dataset.roundIndex = roundIndex;

                roundMatches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.classList.add('match');
                    matchDiv.id = `match-${eventId}-${match.id}`; 
                    
                    const team1Name = getTeamNameById(currentEventId, match.team1Id) || (match.team1Id === 'BYE' ? 'BYE' : 'TBD');
                    const team2Name = getTeamNameById(currentEventId, match.team2Id) || (match.team2Id === 'BYE' ? 'BYE' : 'TBD');
                    
                    let scoreInputs1 = '', scoreInputs2 = '';
                    
                    // Waterfall consolations are single game by default (isSF=false, isFinal=false in createMatchObject for them)
                    const isBo3 = (drawTypePrefix === 'MD' && (match.isSF || match.isFinal || match.isOverallChampionship)) || 
                                  (drawTypePrefix === 'CD' && match.isFinal && !match.isThirdPlacePlayoff);
                                  // Add for WCD if its final is Bo3: || (drawTypePrefix === 'WCD' && match.isFinal)
                    const numGamesToPlay = isBo3 ? 3 : 1;

                    match.score1 = match.score1 || [];
                    match.score2 = match.score2 || [];

                    for (let g = 0; g < numGamesToPlay; g++) {
                        scoreInputs1 += `<input type="number" class="score-input team1-game${g+1}" min="0" max="30" ${match.isComplete ? 'disabled' : ''} value="${match.score1[g] !== undefined && match.score1[g] !== null ? match.score1[g] : ''}" title="Game ${g+1} Score for ${team1Name}"> `;
                        scoreInputs2 += `<input type="number" class="score-input team2-game${g+1}" min="0" max="30" ${match.isComplete ? 'disabled' : ''} value="${match.score2[g] !== undefined && match.score2[g] !== null ? match.score2[g] : ''}" title="Game ${g+1} Score for ${team2Name}"> `;
                    }
                    
                    let matchLabel = match.customLabel || `${match.id}`;
                    if (isBo3 && match.customLabel && !match.customLabel.toLowerCase().includes("best of 3")) matchLabel += " (Best of 3)";

                    matchDiv.innerHTML = `
                        <div class="match-meta">${matchLabel}</div>
                        <div class="team ${match.winnerId === match.team1Id && match.isComplete ? 'winner' : (match.loserId === match.team1Id && match.isComplete ? 'loser' : '')}">
                            <span class="team-name">${team1Name}</span>
                            <span class="scores-container">${scoreInputs1}</span>
                        </div>
                        <div class="team ${match.winnerId === match.team2Id && match.isComplete ? 'winner' : (match.loserId === match.team2Id && match.isComplete ? 'loser' : '')}">
                            <span class="team-name">${team2Name}</span>
                            <span class="scores-container">${scoreInputs2}</span>
                        </div>
                        ${!match.isComplete && match.team1Id && match.team2Id && match.team1Id !== 'BYE' && match.team2Id !== 'BYE' ? 
                            `<button class="save-score" onclick="handleScoreSave('${currentEventId}', '${drawTypePrefix}', '${match.id}')">Save Score</button>` : ''}
                        ${match.isBye ? `<div class="bye">${getTeamNameById(currentEventId, match.winnerId)} advances (BYE)</div>` : ''}
                        ${match.isComplete && !match.isBye ? `<div class="match-complete-indicator">Winner: ${getTeamNameById(currentEventId, match.winnerId)}</div>` : ''}
                    `;
                    roundDiv.appendChild(matchDiv);
                });
                container.appendChild(roundDiv);
            });
        }

        function getTeamNameById(eventId, teamId) {
            if (!teamId) return 'TBD'; 
            if (teamId === 'BYE') return 'BYE';
            const event = tournamentData[eventId];
            if (!event || !event.teams) return teamId; 
            const team = event.teams.find(t => t.id === teamId);
            return team ? team.name : teamId; 
        }
        
        function findMatchById(eventId, drawTypePrefix, matchId) {
            const event = tournamentData[eventId];
            if (!event) return null;
            
            let draw;
            if (drawTypePrefix === 'MD') draw = event.mainDraw;
            else if (drawTypePrefix === 'CD') draw = event.consolationDraw;
            else if (drawTypePrefix === 'WCD') draw = event.waterfallConsolationDraw; // Added
            else return null; 

            if (!draw || !draw.rounds) return null;
            for (const round of draw.rounds) {
                const foundMatch = round.find(m => m.id === matchId);
                if (foundMatch) return foundMatch;
            }
            return null;
        }

        // --- Scoring Rules ---
        function checkGameWinner(s1, s2) {
            if (s1 === null || s2 === null || s1 === undefined || s2 === undefined || String(s1).trim() === '' || String(s2).trim() === '') return null; 

            const p1 = parseInt(s1);
            const p2 = parseInt(s2);
            
            if (isNaN(p1) || isNaN(p2)) return null;

            if (p1 === 30 && p1 > p2) return 1; 
            if (p2 === 30 && p2 > p1) return 2; 
            if (p1 < 30 && p2 < 30) { 
                if (p1 >= 21 && p1 >= p2 + 2) return 1; 
                if (p2 >= 21 && p2 >= p1 + 2) return 2; 
            }
            return null; 
        }

        // --- Score Handling and Advancement ---
        function handleScoreSave(eventId, drawTypePrefix, matchId) {
            const match = findMatchById(eventId, drawTypePrefix, matchId);
            if (!match) { console.error("Match not found:", matchId); return; }

            const isBo3 = (drawTypePrefix === 'MD' && (match.isSF || match.isFinal || match.isOverallChampionship)) || 
                          (drawTypePrefix === 'CD' && match.isFinal && !match.isThirdPlacePlayoff);
                          // WCD matches are single game by default
            const numGamesToPlay = isBo3 ? 3 : 1;
            
            const collectedScores1 = [], collectedScores2 = [];
            const matchDiv = document.getElementById(`match-${eventId}-${match.id}`);
            if (!matchDiv) { console.error("Match div not found:", `match-${eventId}-${match.id}`); return; }

            for (let g = 0; g < numGamesToPlay; g++) {
                const s1El = matchDiv.querySelector(`.team1-game${g+1}`);
                const s2El = matchDiv.querySelector(`.team2-game${g+1}`);
                if (!s1El || !s2El) { collectedScores1.push(null); collectedScores2.push(null); continue;}

                const s1Val = s1El.value;
                const s2Val = s2El.value;
                
                collectedScores1.push(s1Val === '' ? null : parseInt(s1Val));
                collectedScores2.push(s2Val === '' ? null : parseInt(s2Val));
            }
            match.score1 = collectedScores1; 
            match.score2 = collectedScores2;

            let team1MatchGamesWon = 0;
            let team2MatchGamesWon = 0;
            let allRequiredGamesValidlyScored = true;

            for (let g = 0; g < numGamesToPlay; g++) {
                if (isBo3 && (team1MatchGamesWon >= 2 || team2MatchGamesWon >= 2)) break; 

                const gameWinner = checkGameWinner(match.score1[g], match.score2[g]);
                if (gameWinner === 1) team1MatchGamesWon++;
                else if (gameWinner === 2) team2MatchGamesWon++;
                else {
                    if (match.score1[g] !== null || match.score2[g] !== null) { 
                       allRequiredGamesValidlyScored = false;
                    }
                }
            }
            
            let determinedWinnerId = null;
            if (!isBo3) { // Single game
                if (team1MatchGamesWon === 1) determinedWinnerId = match.team1Id;
                else if (team2MatchGamesWon === 1) determinedWinnerId = match.team2Id;
                else { allRequiredGamesValidlyScored = false; } 
            } else { // Best of 3
                if (team1MatchGamesWon >= 2) determinedWinnerId = match.team1Id;
                else if (team2MatchGamesWon >= 2) determinedWinnerId = match.team2Id;
                else { allRequiredGamesValidlyScored = false; } 
            }
            
            if (!allRequiredGamesValidlyScored) {
                alert(`Match scores for ${match.id} are incomplete or invalid. Check all scores.`);
                match.winnerId = null; 
                match.loserId = null;
                match.isComplete = false;
                saveData(); 
                renderCurrentEvent(); 
                return;
            }
            
            match.winnerId = determinedWinnerId;
            match.loserId = (match.winnerId === match.team1Id) ? match.team2Id : match.team1Id;
            match.isComplete = true;

            if (!match.isOverallChampionship && !match.isThirdPlacePlayoff) {
                const loserTeamObj = tournamentData[eventId].teams.find(t => t.id === match.loserId);
                if (loserTeamObj) { 
                    if (drawTypePrefix === 'MD') {
                        loserTeamObj.mainDrawLosses = (loserTeamObj.mainDrawLosses || 0) + 1;
                    } else if (drawTypePrefix === 'CD') { 
                        loserTeamObj.consolationLosses = (loserTeamObj.consolationLosses || 0) + 1;
                    }
                    // No specific loss tracking for WCD on the team object for now
                }
            }
            
            saveData();
            renderCurrentEvent(); 
        }
        
        function populateAllDrawsForEvent(eventId) {
            const event = tournamentData[eventId];
            if (!event) return;
            
            let maxIterations = 10; // Increased slightly for deeper propagation if needed
            let iteration = 0;
            let changedInIteration;

            do {
                changedInIteration = false;
                const snapshot = (draw) => draw && draw.rounds ? draw.rounds.map(r => r.map(m => `${m.id}:${m.team1Id}-${m.team2Id}:${m.isComplete}`)) : [];
                const originalAssignments = JSON.stringify({
                    md: snapshot(event.mainDraw),
                    cd: snapshot(event.consolationDraw),
                    wfcd: snapshot(event.waterfallConsolationDraw) // Added
                });

                populateSpecificDraw(eventId, event.mainDraw, 'MD');
                populateSpecificDraw(eventId, event.consolationDraw, 'CD');
                populateSpecificDraw(eventId, event.waterfallConsolationDraw, 'WCD'); // Added

                const newAssignments = JSON.stringify({
                    md: snapshot(event.mainDraw),
                    cd: snapshot(event.consolationDraw),
                    wfcd: snapshot(event.waterfallConsolationDraw) // Added
                });
                
                if (originalAssignments !== newAssignments) {
                    changedInIteration = true;
                }
                iteration++;
            } while (changedInIteration && iteration < maxIterations);
             if (iteration === maxIterations && changedInIteration) {
                console.warn("Max population iterations reached. Draw might not be fully stable.");
            }
        }

        function populateSpecificDraw(eventId, drawData, drawTypePrefix) {
            if (!drawData || !drawData.rounds) return;

            drawData.rounds.forEach(round => {
                round.forEach(match => {
                    if (match.isComplete && !match.isBye) return; 
                                                
                    if (!match.team1Id || match.team1Id === 'TBD') { 
                        const p1Id = getPlayerIdFromSource(eventId, match.team1Source); 
                        if (p1Id) match.team1Id = p1Id;
                    }
                    if (!match.team2Id || match.team2Id === 'TBD') {
                        const p2Id = getPlayerIdFromSource(eventId, match.team2Source); 
                        if (p2Id) match.team2Id = p2Id;
                    }

                    if (!match.isComplete) { 
                        let newByeWinner = null;
                        if (match.team1Id === 'BYE' && match.team2Id && match.team2Id !== 'BYE' && match.team2Id !== 'TBD') {
                            newByeWinner = match.team2Id;
                        } else if (match.team2Id === 'BYE' && match.team1Id && match.team1Id !== 'BYE' && match.team1Id !== 'TBD') {
                            newByeWinner = match.team1Id;
                        } else if (match.team1Id === 'BYE' && match.team2Id === 'BYE') {
                            newByeWinner = 'BYE'; 
                        }
                        
                        if (newByeWinner) {
                             match.winnerId = newByeWinner;
                             match.loserId = (newByeWinner === match.team1Id) ? match.team2Id : match.team1Id; 
                             match.isComplete = true; match.isBye = true;
                             match.score1 = []; match.score2 = []; 
                        }
                    }

                    // Feed losers to next specified bracket (CD or WCD)
                    if (match.isComplete && match.loserId && match.loserFeedsToNextBracketMatchId && match.nextBracketType) {
                        const loserIdToFeed = match.loserId; 
                        const targetDrawTypePrefix = match.nextBracketType; // 'CD' or 'WCD'
                        const targetMatchToFeed = findMatchById(eventId, targetDrawTypePrefix, match.loserFeedsToNextBracketMatchId);

                        if (targetMatchToFeed && !targetMatchToFeed.isComplete) { 
                            let slotFilledThisIteration = false;
                            if (match.loserFeedsToNextBracketSlotNumber === 1 && (!targetMatchToFeed.team1Id || targetMatchToFeed.team1Id === 'TBD')) {
                                targetMatchToFeed.team1Id = loserIdToFeed;
                                slotFilledThisIteration = true;
                            } else if (match.loserFeedsToNextBracketSlotNumber === 2 && (!targetMatchToFeed.team2Id || targetMatchToFeed.team2Id === 'TBD')) {
                                targetMatchToFeed.team2Id = loserIdToFeed;
                                slotFilledThisIteration = true;
                            }

                            if (slotFilledThisIteration && !targetMatchToFeed.isComplete) {
                                let targetByeWinner = null;
                                if (targetMatchToFeed.team1Id === 'BYE' && targetMatchToFeed.team2Id && targetMatchToFeed.team2Id !== 'BYE' && targetMatchToFeed.team2Id !== 'TBD') {
                                    targetByeWinner = targetMatchToFeed.team2Id;
                                } else if (targetMatchToFeed.team2Id === 'BYE' && targetMatchToFeed.team1Id && targetMatchToFeed.team1Id !== 'BYE' && targetMatchToFeed.team1Id !== 'TBD') {
                                    targetByeWinner = targetMatchToFeed.team1Id;
                                }
                                if (targetByeWinner) {
                                    targetMatchToFeed.winnerId = targetByeWinner;
                                    targetMatchToFeed.loserId = (targetByeWinner === targetMatchToFeed.team1Id) ? targetMatchToFeed.team2Id : targetMatchToFeed.team1Id;
                                    targetMatchToFeed.isComplete = true; targetMatchToFeed.isBye = true;
                                    targetMatchToFeed.score1 = []; targetMatchToFeed.score2 = [];
                                }
                            }
                        }
                    }
                });
            });
        }

        function getPlayerIdFromSource(eventId, source) { 
            if (!source) return null;
            const event = tournamentData[eventId];
            if (!event) return null;

            if (source.type === 'seed') {
                if (event.teams && event.teams[source.slot]) {
                    return event.teams[source.slot].id;
                }
                return event.teams[source.slot] ? event.teams[source.slot].id : null;
            } else if (source.type === 'winner') {
                let sourceDrawType;
                if (source.matchId.startsWith('M')) sourceDrawType = 'MD';
                else if (source.matchId.startsWith('CD')) sourceDrawType = 'CD';
                else if (source.matchId.startsWith('WCD')) sourceDrawType = 'WCD';
                else return null;

                const sourceMatch = findMatchById(eventId, sourceDrawType, source.matchId);
                if (sourceMatch && sourceMatch.isComplete) {
                    return sourceMatch.winnerId; 
                }
                return null; 
            } else if (source.type === 'loser') {
                let sourceDrawType;
                if (source.matchId.startsWith('M')) sourceDrawType = 'MD';
                else if (source.matchId.startsWith('CD')) sourceDrawType = 'CD';
                // WCD losers don't feed anywhere else currently, but if they did, add 'WCD' here
                else return null;
                
                const sourceMatch = findMatchById(eventId, sourceDrawType, source.matchId);
                
                if (sourceMatch && sourceMatch.isComplete) {
                    if (sourceMatch.isBye) {
                        if (sourceMatch.team1Id === 'BYE' && sourceMatch.winnerId === sourceMatch.team2Id) return 'BYE';
                        if (sourceMatch.team2Id === 'BYE' && sourceMatch.winnerId === sourceMatch.team1Id) return 'BYE';
                        if (sourceMatch.winnerId === 'BYE') return 'BYE';
                    }
                    return sourceMatch.loserId; 
                }
                return null; 
            }
            return null;
        }

        // --- Entry Point ---
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
